/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray2(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array = format3.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format3) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format3) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m);
      }
      function expandFormat(format3, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format3) ? format3(output) : format3.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex2, strictRegex) {
        regexes[token2] = isFunction(regex2) ? regex2 : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex2;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format3) {
        if (!m) {
          return isArray2(this._months) ? this._months : this._months["standalone"];
        }
        return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format3) {
        if (!m) {
          return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i, mom, regex2;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex2.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format3) {
        var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i, mom, regex2;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex2.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray2(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray2(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray2(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
        var c = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format3;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray2(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray2(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff2 = myMoment.diff(now3, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format3]) ? formats[format3].call(this, now3) : formats[format3]);
        return this.format(
          output || this.localeData().calendar(format3, this, createLocal(now3))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString2() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format3) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString2;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format3, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format3);
      }
      function listMonthsImpl(format3, index, field) {
        if (isNumber2(format3)) {
          index = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index != null) {
          return get$1(format3, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format3, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index = format3;
          localeSorted = false;
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format3, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format3, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index) {
        return listMonthsImpl(format3, index, "months");
      }
      function listMonthsShort(format3, index) {
        return listMonthsImpl(format3, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble2() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble2;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StructuredTreePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian33 = require("obsidian");

// src/view.ts
var import_obsidian11 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block3, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block3(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/svelte/easing/index.mjs
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/transition/index.mjs
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// src/engine/note.ts
var Note = class {
  constructor(originalName, titlecase, settings) {
    this.originalName = originalName;
    this.titlecase = titlecase;
    this.settings = settings;
    this.children = [];
    this.metadata = {};
    this.name = originalName.toLowerCase();
    this.syncMetadata(void 0);
    this.sortKey = this.title.toLowerCase();
  }
  appendChild(note) {
    if (note.parent)
      throw Error("Note has parent");
    note.parent = this;
    this.children.push(note);
  }
  removeChildren(note) {
    note.parent = void 0;
    const index = this.children.indexOf(note);
    this.children.splice(index, 1);
  }
  findChildren(name) {
    const lower = name.toLowerCase();
    return this.children.find((note) => note.name == lower);
  }
  sortChildren(recursive) {
    this.children.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
    if (recursive)
      this.children.forEach((child) => child.sortChildren(recursive));
  }
  getPath(original = false) {
    const component = [];
    const notes = this.getPathNotes();
    if (notes.length === 1)
      return original ? notes[0].originalName : notes[0].name;
    for (const note of notes) {
      if (!note.parent && note.name === "root")
        continue;
      component.push(original ? note.originalName : note.name);
    }
    return component.join(".");
  }
  getPathNotes() {
    const notes = [];
    let current = this;
    while (current) {
      notes.unshift(current);
      current = current.parent;
    }
    return notes;
  }
  syncMetadata(metadata) {
    this.metadata = metadata || {};
    if (!this.metadata[this.settings.titleKey]) {
      this.metadata[this.settings.titleKey] = generateNoteTitle(this.originalName, this.titlecase);
    } else {
      this.metadata[this.settings.titleKey] = String(this.metadata[this.settings.titleKey]);
    }
    if (this.metadata[this.settings.descKey] === void 0) {
      this.metadata[this.settings.descKey] = "";
    }
    this.updateSortKey();
  }
  updateSortKey() {
    this.sortKey = this.title.toLowerCase();
  }
  get title() {
    return String(this.metadata[this.settings.titleKey] || this.name);
  }
  get desc() {
    return this.metadata[this.settings.descKey] || "";
  }
};
function isUseTitleCase(baseName) {
  return baseName.toLowerCase() === baseName;
}
function generateNoteTitle(originalName, titlecase) {
  if (!titlecase)
    return originalName;
  return originalName.split("-").map((item) => item.trim()).filter((item) => item.length > 0).map((word) => {
    return word[0].toUpperCase() + word.substring(1).toLowerCase();
  }).join(" ");
}

// src/components/NoteComponent.svelte
var import_obsidian9 = require("obsidian");

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/store.ts
var plugin = writable();
var getPlugin = () => get_store_value(plugin);
var activeFile = writable();
var structuredVaultList = writable([]);
var selectedNotes = writable([]);
var showVaultPath = derived(structuredVaultList, ($list) => $list.length > 1);

// src/utils.ts
var import_obsidian = require("obsidian");

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// src/utils.ts
var import_child_process = require("child_process");
function getFolderFile(vault, path) {
  return path.length === 0 ? vault.getRoot() : vault.getAbstractFileByPath(path);
}
function openFile(app, file, props = {}) {
  if (!file || !(file instanceof import_obsidian.TFile))
    return;
  const leaf = props.openTarget === "new-window" ? app.workspace.openPopoutLeaf() : props.openTarget === "new-leaf" ? app.workspace.createLeafBySplit(app.workspace.getLeaf()) : app.workspace.getLeaf(props.openTarget === "new-tab");
  return leaf.openFile(file, props.openState);
}
var alphanumericLowercase = "0123456789abcdefghijklmnopqrstuvwxyz";
var generateUUID = customAlphabet(alphanumericLowercase, 23);
function isDesktopApp() {
  return import_obsidian.Platform.isDesktop;
}
function showInSystemExplorer(app, relativePath) {
  var _a, _b;
  if (!isDesktopApp())
    return;
  const vaultPath = (_b = (_a = app.vault.adapter).getBasePath) == null ? void 0 : _b.call(_a);
  if (!vaultPath) {
    console.error("Unable to get vault path");
    return;
  }
  const absolutePath = `${vaultPath}/${relativePath}`;
  if (import_obsidian.Platform.isWin) {
    const windowsPath = absolutePath.replace(/\//g, "\\");
    (0, import_child_process.exec)(`explorer.exe /select,"${windowsPath}"`, (error) => {
      if (error)
        console.error("Failed to open explorer:", error);
    });
  } else if (import_obsidian.Platform.isMacOS) {
    (0, import_child_process.exec)(`open -R "${absolutePath}"`, (error) => {
      if (error)
        console.error("Failed to open finder:", error);
    });
  } else if (import_obsidian.Platform.isLinux) {
    const dirPath = absolutePath.substring(0, absolutePath.lastIndexOf("/"));
    (0, import_child_process.exec)(`xdg-open "${dirPath}"`, (error) => {
      if (error)
        console.error("Failed to open file manager:", error);
    });
  }
}

// src/modal/lookup/lookupModal.ts
var import_obsidian4 = require("obsidian");

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/pathExclusion.ts
function isPathExcluded(path, excludedPaths) {
  return excludedPaths.some((pattern) => {
    const regexPattern = pattern.replace(/\./g, "\\.").replace(/\*/g, ".*");
    const regex2 = new RegExp(`^${regexPattern}`);
    return regex2.test(path);
  });
}

// src/modal/lookup/lookupSuggestionManager.ts
var LookupSuggestionManager = class {
  constructor(workspace, excludedPaths = []) {
    this.workspace = workspace;
    this.excludedPaths = excludedPaths;
    this.activeFile = null;
    this.initializeNotes();
    this.initializeFuse();
  }
  setActiveFile(file) {
    this.activeFile = file;
  }
  initializeNotes() {
    this.allNotes = this.workspace.vaultList.filter((vault) => !vault.config.isSecret).flatMap(
      (vault) => vault.tree.flatten().map((note) => ({
        note,
        vault,
        excluded: isPathExcluded(note.getPath(), this.excludedPaths),
        exists: !!note.file
      }))
    );
    this.allNotes.sort((a, b) => {
      if (a.excluded !== b.excluded) {
        return a.excluded ? 1 : -1;
      }
      const aTitle = a.note.title || a.note.name;
      const bTitle = b.note.title || b.note.name;
      return aTitle.localeCompare(bTitle);
    });
  }
  initializeFuse() {
    const settings = this.workspace.settings;
    this.fuse = new Fuse(this.allNotes, {
      keys: [
        "note.title",
        "note.name",
        {
          name: "note.file.name",
          weight: settings.fuzzySearchFileNameWeight
        }
      ],
      includeScore: true,
      includeMatches: true,
      threshold: settings.fuzzySearchThreshold
    });
  }
  getSuggestions(query) {
    let results;
    if (!query.trim()) {
      results = this.allNotes.filter((item) => !item.excluded);
    } else if (query.length > 60) {
      const exactMatch2 = this.allNotes.find(
        (item) => item.note.getPath().toLowerCase() === query.toLowerCase()
      );
      if (exactMatch2) {
        results = [exactMatch2];
      } else {
        results = this.allNotes.filter(
          (item) => item.note.getPath().toLowerCase().includes(query.toLowerCase())
        );
      }
    } else {
      const fuzzyResults = this.fuse.search(query);
      results = fuzzyResults.map((r) => ({ ...r.item, matches: r.matches }));
    }
    results.sort((a, b) => {
      if (a.excluded !== b.excluded) {
        return a.excluded ? 1 : -1;
      }
      return a.note.getPath().toLowerCase().indexOf(query.toLowerCase()) - b.note.getPath().toLowerCase().indexOf(query.toLowerCase());
    });
    const exactMatch = results.find(
      (item) => item.note.getPath().toLowerCase() === query.toLowerCase()
    );
    const lookupResults = results.slice(0, 10);
    if (!exactMatch && query.trim().length > 0) {
      lookupResults.push({ type: "create_new" });
    }
    return lookupResults;
  }
};

// src/modal/lookup/lookupRenderer.ts
var import_obsidian2 = require("obsidian");

// src/modal/lookup/lookupUtils.ts
var LookupUtils = class {
  static isLookupItem(item) {
    return item.note !== void 0;
  }
  static refreshNoteMetadata(item) {
    if (item && item.note.file) {
      const metadata = item.vault.resolveMetadata(item.note.file);
      if (metadata) {
        item.note.syncMetadata(metadata);
      }
    }
  }
  static highlightMatches(text2, matches, keys) {
    if (!matches)
      return null;
    const relevantMatches = matches.filter((m) => m.key && keys.includes(m.key));
    if (relevantMatches.length === 0)
      return null;
    let highlightedText = "";
    let lastIndex = 0;
    const indices = relevantMatches.flatMap((m) => m.indices).sort((a, b) => a[0] - b[0]);
    indices.forEach(([start, end]) => {
      if (start < lastIndex)
        return;
      highlightedText += text2.slice(lastIndex, start);
      highlightedText += `<b>${text2.slice(start, end + 1)}</b>`;
      lastIndex = end + 1;
    });
    highlightedText += text2.slice(lastIndex);
    return highlightedText !== text2 ? highlightedText : null;
  }
  static async createNote(vault, path) {
    return await vault.createNote(path);
  }
};

// src/modal/lookup/lookupRenderer.ts
var LookupRenderer = class {
  constructor(workspace) {
    this.workspace = workspace;
  }
  renderSuggestion(item, el) {
    if (LookupUtils.isLookupItem(item)) {
      this.renderLookupItem(item, el);
    } else {
      this.renderCreateNew(el);
    }
  }
  renderLookupItem(item, el) {
    el.classList.add("mod-complex");
    const path = item.note.getPath();
    if (path) {
      el.dataset["path"] = path;
    }
    if (item.excluded) {
      el.addClass("excluded-path");
    }
    el.createEl("div", { cls: "suggestion-content" }, (el2) => {
      const titleContainer = el2.createEl("div", { cls: "suggestion-title" });
      const titleText = item.note.title || item.note.name;
      const highlightedTitle = LookupUtils.highlightMatches(titleText, item.matches, [
        "note.title",
        "note.name"
      ]);
      const highlightedPath = LookupUtils.highlightMatches(path || "", item.matches, [
        "note.getPath",
        "note.file.name"
      ]);
      titleContainer.innerHTML = highlightedTitle || titleText;
      const pathAndVaultSpan = titleContainer.createSpan({ cls: "suggestion-path" });
      if (path) {
        pathAndVaultSpan.innerHTML = ` - ${highlightedPath || path}`;
      }
      if (this.workspace.vaultList.length > 1) {
        pathAndVaultSpan.appendText(` (${item.vault.config.name})`);
      }
      if (item.excluded) {
        titleContainer.createSpan({ cls: "excluded-label" });
      }
      el2.createEl("small", {
        text: item.note.desc || "",
        cls: "suggestion-content"
      });
    });
    if (!item.exists) {
      el.createEl("div", { cls: "suggestion-aux" }, (el2) => {
        const icon = (0, import_obsidian2.getIcon)("plus");
        if (icon) {
          el2.append(icon);
        } else {
          el2.textContent = "+";
        }
      });
    }
  }
  renderCreateNew(el) {
    el.classList.add("mod-complex");
    el.createEl("div", { cls: "suggestion-content" }, (el2) => {
      const titleContainer = el2.createEl("div", { cls: "suggestion-title" });
      titleContainer.createSpan({ text: "Create New" });
      el2.createEl("small", {
        text: "Note does not exist",
        cls: "suggestion-content"
      });
    });
    el.createEl("div", { cls: "suggestion-aux" }, (el2) => {
      const icon = (0, import_obsidian2.getIcon)("plus");
      if (icon) {
        el2.append(icon);
      } else {
        el2.textContent = "+";
      }
    });
  }
  highlightMatches(text2, matches, keys) {
    if (!matches)
      return null;
    const relevantMatches = matches.filter((m) => m.key && keys.includes(m.key));
    if (relevantMatches.length === 0)
      return null;
    let highlightedText = "";
    let lastIndex = 0;
    const indices = relevantMatches.flatMap((m) => m.indices).sort((a, b) => a[0] - b[0]);
    indices.forEach(([start, end]) => {
      if (start < lastIndex)
        return;
      highlightedText += text2.slice(lastIndex, start);
      highlightedText += `<b>${text2.slice(start, end + 1)}</b>`;
      lastIndex = end + 1;
    });
    highlightedText += text2.slice(lastIndex);
    return highlightedText !== text2 ? highlightedText : null;
  }
  isLookupItem(item) {
    return item.note !== void 0;
  }
};

// src/modal/selectVaultModal.ts
var import_obsidian3 = require("obsidian");
var SelectVaultModal = class extends import_obsidian3.SuggestModal {
  constructor(app, workspace, onSelected) {
    super(app);
    this.workspace = workspace;
    this.onSelected = onSelected;
  }
  getSuggestions(query) {
    const queryLowercase = query.toLowerCase();
    const activeFile2 = this.app.workspace.getActiveFile();
    return this.workspace.vaultList.filter((vault) => {
      const matchesQuery = vault.config.path.toLowerCase().contains(queryLowercase) || vault.config.name.toLowerCase().contains(queryLowercase);
      const isAccessible = vault.isAccessibleFrom(activeFile2);
      return matchesQuery && isAccessible;
    });
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value.config.name });
    el.createEl("small", {
      text: value.config.path
    });
  }
  onChooseSuggestion(item, evt) {
    this.onSelected(item);
  }
};

// src/modal/lookup/lookupActionHandler.ts
var LookupActionHandler = class {
  constructor(app, workspace) {
    this.app = app;
    this.workspace = workspace;
  }
  async onChooseSuggestion(item, inputValue) {
    if (LookupUtils.isLookupItem(item) && item.note.file) {
      openFile(this.app, item.note.file);
      return;
    }
    const path = LookupUtils.isLookupItem(item) ? item.note.getPath() : inputValue;
    const doCreate = async (vault) => {
      const file = await LookupUtils.createNote(vault, path);
      return openFile(vault.app, file);
    };
    if (LookupUtils.isLookupItem(item) && item.vault) {
      await doCreate(item.vault);
    } else if (this.workspace.vaultList.length == 1) {
      await doCreate(this.workspace.vaultList[0]);
    } else {
      new SelectVaultModal(this.app, this.workspace, doCreate).open();
    }
  }
};

// src/modal/lookup/lookupModal.ts
var LookupModal = class extends import_obsidian4.SuggestModal {
  constructor(app, workspace, initialQuery = "", onCreateInVault, excludedPaths = []) {
    super(app);
    this.workspace = workspace;
    this.initialQuery = initialQuery;
    this.onCreateInVault = onCreateInVault;
    this.excludedPaths = excludedPaths;
    this.lastQuery = "";
    this.suggestionManager = new LookupSuggestionManager(workspace, excludedPaths);
    this.renderer = new LookupRenderer(workspace);
    this.actionHandler = new LookupActionHandler(app, workspace);
    this.inputEl.setAttribute("spellcheck", "false");
    this.debouncedGetSuggestions = (0, import_obsidian4.debounce)(
      (query, callback) => {
        this.lastQuery = query;
        const suggestions = this.suggestionManager.getSuggestions(query);
        callback(suggestions);
      },
      150
    );
    this.inputEl.addEventListener("keyup", (event) => {
      if (event.code === "Tab") {
        const selectedElement = this.resultContainerEl.querySelector(
          ".is-selected"
        );
        if (selectedElement) {
          const path = selectedElement.dataset["path"];
          if (path) {
            this.inputEl.value = path;
            this.inputEl.dispatchEvent(new Event("input"));
          }
        }
      }
    });
  }
  onOpen() {
    super.onOpen();
    if (this.initialQuery.length > 0) {
      this.inputEl.value = this.initialQuery;
      this.inputEl.dispatchEvent(new Event("input"));
    }
  }
  getSuggestions(query) {
    return new Promise((resolve) => {
      this.debouncedGetSuggestions(query, resolve);
    });
  }
  renderSuggestion(item, el) {
    if (LookupUtils.isLookupItem(item)) {
      LookupUtils.refreshNoteMetadata(item);
    }
    this.renderer.renderSuggestion(item, el);
  }
  async onChooseSuggestion(item, evt) {
    if (this.onCreateInVault) {
      await this.onCreateInVault(this.inputEl.value);
    } else {
      await this.actionHandler.onChooseSuggestion(item, this.inputEl.value);
    }
  }
};

// src/commands/createNewNote.ts
function createNewNoteCommand(app, workspace) {
  return {
    id: "structured-tree-create-note",
    name: "Create new note",
    callback: () => openLookupWithCurrentPath(app, workspace)
  };
}
function openLookupWithCurrentPath(app, workspace, initialPath, sourceVault) {
  let path = initialPath;
  if (!path) {
    const activeFile2 = app.workspace.getActiveFile();
    if (activeFile2) {
      const activeVault = workspace.findVaultByParent(activeFile2.parent);
      if (activeVault) {
        const note = activeVault.tree.getFromFileName(activeFile2.basename, workspace.settings);
        if (note) {
          path = note.getPath(true) + ".";
        }
      }
    }
  }
  if (!sourceVault) {
    const activeFile2 = app.workspace.getActiveFile();
    if (activeFile2) {
      sourceVault = workspace.findVaultByParent(activeFile2.parent);
    }
  }
  const modal = new LookupModal(
    app,
    workspace,
    path,
    sourceVault ? async (inputValue) => {
      if (sourceVault) {
        const vault = sourceVault;
        const file = await vault.createNote(inputValue);
        if (file)
          app.workspace.getLeaf().openFile(file);
      }
    } : void 0
  );
  modal.open();
}

// src/engine/structuredVault.ts
var import_obsidian6 = require("obsidian");

// src/engine/noteTree.ts
var NoteTree = class {
  constructor(settings) {
    this.root = new Note("root", true, settings);
  }
  sort() {
    this.root.sortChildren(true);
  }
  static getPathFromFileName(name, separator) {
    return name.split(separator || ".");
  }
  static isRootPath(path) {
    return path.length === 1 && path[0] === "root";
  }
  addFile(file, settings, sort = false) {
    const titlecase = isUseTitleCase(file.basename);
    const path = NoteTree.getPathFromFileName(file.basename, settings.hierarchySeparator);
    let currentNote = this.root;
    if (!NoteTree.isRootPath(path))
      for (const name of path) {
        let note = currentNote.findChildren(name);
        if (!note) {
          note = new Note(name, titlecase, settings);
          currentNote.appendChild(note);
          if (sort)
            currentNote.sortChildren(false);
        }
        currentNote = note;
      }
    this.updateNoteFile(currentNote, file);
    return currentNote;
  }
  updateNoteFile(note, file) {
    note.file = file;
    if (note.title) {
      note.sortKey = note.title.toLowerCase();
    } else {
      note.sortKey = file.basename.toLowerCase();
    }
    if (note.parent) {
      note.parent.sortChildren(false);
    }
  }
  getFromFileName(name, settings) {
    const path = NoteTree.getPathFromFileName(name, settings.hierarchySeparator);
    if (NoteTree.isRootPath(path))
      return this.root;
    let currentNote = this.root;
    for (const name2 of path) {
      const found = currentNote.findChildren(name2);
      if (!found)
        return void 0;
      currentNote = found;
    }
    return currentNote;
  }
  deleteByFileName(name, settings) {
    const note = this.getFromFileName(name, settings);
    if (!note)
      return;
    note.file = void 0;
    if (note.children.length == 0) {
      let currentNote = note;
      while (currentNote && currentNote.parent && !currentNote.file && currentNote.children.length == 0) {
        const parent = currentNote.parent;
        parent.removeChildren(currentNote);
        currentNote = parent;
      }
    }
    return note;
  }
  static *flattenInternal(root) {
    yield root;
    for (const child of root.children)
      yield* this.flattenInternal(child);
  }
  flatten() {
    return Array.from(NoteTree.flattenInternal(this.root));
  }
};

// src/modal/invalidRootModal.ts
var import_obsidian5 = require("obsidian");
var InvalidRootModal = class extends import_obsidian5.Modal {
  constructor(structuredVault) {
    super(structuredVault.app);
    this.structuredVault = structuredVault;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Invalid Root" });
    this.contentEl.createEl("p", {
      text: `"${this.structuredVault.config.path}" is not folder. Do you want to create this folder?`
    });
    new import_obsidian5.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Create").setCta().onClick(async () => {
        await this.structuredVault.createRootFolder();
        this.structuredVault.init();
        this.close();
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/engine/structuredVault.ts
var import_moment = __toESM(require_moment());

// src/engine/noteFinder.ts
var getFullPathWithoutExtension = (path) => {
  const extension = path.split(".").pop();
  if (!extension) {
    return "";
  }
  const extLength = extension.length + 1;
  return path.slice(0, path.length - extLength);
};
var NoteFinder = class {
  constructor(app) {
    this.app = app;
  }
  findChildren(file) {
    const allNotes = this.findNotes();
    return allNotes.filter((n) => {
      return n.path.includes(file.path.slice(0, file.path.length - 3)) && n.parent == file.parent && n != file;
    });
  }
  findParents(file) {
    const allNotes = this.findNotes();
    return allNotes.filter((n) => {
      return getFullPathWithoutExtension(file.path).startsWith(getFullPathWithoutExtension(n.path)) && n.parent == file.parent && n != file;
    });
  }
  findNotes() {
    return this.app.vault.getMarkdownFiles();
  }
  getParentName(file) {
    const noteNamePath = file.basename.split(".");
    if (noteNamePath.length > 1) {
      noteNamePath.pop();
      return noteNamePath.join(".");
    }
    return null;
  }
};

// src/engine/noteRenamer.ts
var NoteRenamer = class {
  constructor(app, finder, noteTree, settings) {
    this.app = app;
    this.finder = finder;
    this.noteTree = noteTree;
    this.settings = settings;
  }
  async renameNote(file, newName) {
    var _a;
    const dirPath = ((_a = file.parent) == null ? void 0 : _a.path) || "";
    const newBasePath = newName;
    const children2 = this.finder.findChildren(file);
    const newNotesNames = children2.map((f) => {
      const childFileName = f.name;
      const newChildName = childFileName.replace(file.basename, newBasePath);
      return {
        file: f,
        newPath: dirPath ? `${dirPath}/${newChildName}` : newChildName
      };
    });
    for (const f of newNotesNames) {
      await this.app.fileManager.renameFile(f.file, f.newPath);
    }
    const extension = file.extension ? `.${file.extension}` : "";
    const newPath = dirPath ? `${dirPath}/${newBasePath}${extension}` : `${newBasePath}${extension}`;
    await this.app.fileManager.renameFile(file, newPath);
    const note = this.noteTree.getFromFileName(file.basename, this.settings);
    if (note) {
      const newFile = this.app.vault.getAbstractFileByPath(newPath);
      if (newFile) {
        this.noteTree.updateNoteFile(note, newFile);
      }
    }
  }
};

// src/supportedExtensions.ts
var supportedExtensions = [
  "md",
  // Markdown files
  "pdf",
  // PDF documents
  "avif",
  // Image files
  "bmp",
  "gif",
  "jpeg",
  "jpg",
  "png",
  "svg",
  "flac",
  // Audio files
  "m4a",
  "mp3",
  "ogg",
  "wav",
  "webm",
  "3gp",
  // Video files
  "mkv",
  "mov",
  "mp4",
  "ogv"
];
function getSupportedExtensions(includeCanvas) {
  const extensions = new Set(supportedExtensions);
  if (includeCanvas) {
    extensions.add("canvas");
  }
  return extensions;
}

// src/engine/structuredVault.ts
var StructuredVault = class {
  constructor(app, config, settings) {
    this.app = app;
    this.config = config;
    this.settings = settings;
    this.isIniatialized = false;
    this.tree = new NoteTree(settings);
    this.noteFinder = new NoteFinder(app);
    this.noteRenamer = new NoteRenamer(app, this.noteFinder, this.tree, this.settings);
    this.updateAcceptedExtensionsCache();
  }
  resolveMetadata(file) {
    var _a;
    const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!frontmatter)
      return void 0;
    return frontmatter;
  }
  init() {
    if (this.isIniatialized)
      return;
    const root = getFolderFile(this.app.vault, this.config.path);
    if (!(root instanceof import_obsidian6.TFolder)) {
      new InvalidRootModal(this).open();
      return;
    }
    this.folder = root;
    for (const child of root.children)
      if (child instanceof import_obsidian6.TFile && this.isNote(child.extension))
        this.tree.addFile(child, this.settings).syncMetadata(this.resolveMetadata(child));
    this.tree.sort();
    this.isIniatialized = true;
  }
  async createRootFolder() {
    return await this.app.vault.createFolder(this.config.path);
  }
  async createNote(baseName) {
    const filePath = `${this.config.path}/${baseName}.md`;
    return await this.app.vault.create(filePath, "");
  }
  getPropertySetting(key) {
    var _a, _b;
    return (_b = (_a = this.config.properties) == null ? void 0 : _a[key]) != null ? _b : this.settings[key];
  }
  async generateFrontmatter(file) {
    if (!this.isNote(file.extension))
      return;
    const note = this.tree.getFromFileName(file.basename, this.settings);
    if (!note)
      return false;
    return await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (this.getPropertySetting("autoGenerateFrontmatter")) {
        if (this.getPropertySetting("generateId") && !frontmatter.id) {
          frontmatter.id = generateUUID();
        }
        if (this.getPropertySetting("generateTitle") && !frontmatter[this.getPropertySetting("titleKey")]) {
          frontmatter[this.getPropertySetting("titleKey")] = note.title;
        }
        if (this.getPropertySetting("generateDesc") && frontmatter[this.getPropertySetting("descKey")] === void 0) {
          frontmatter[this.getPropertySetting("descKey")] = note.desc;
        }
        if (this.getPropertySetting("generateCreated") && !frontmatter[this.getPropertySetting("createdKey")]) {
          if (this.getPropertySetting("createdFormat") === "unix") {
            frontmatter[this.getPropertySetting("createdKey")] = file.stat.ctime;
          } else {
            frontmatter[this.getPropertySetting("createdKey")] = (0, import_moment.default)(file.stat.ctime).format(
              "YYYY-MM-DD"
            );
          }
        }
        if (this.getPropertySetting("generateTags") && !frontmatter.tags) {
          frontmatter.tags = [];
        }
      }
    });
  }
  updateAcceptedExtensionsCache() {
    this._cachedAcceptedExtensions = getSupportedExtensions(this.settings.enableCanvasSupport);
  }
  get acceptedExtensions() {
    return this._cachedAcceptedExtensions;
  }
  isNote(extension) {
    return this.acceptedExtensions.has(extension);
  }
  onFileCreated(file) {
    if (!(file instanceof import_obsidian6.TFile) || !this.isNote(file.extension))
      return false;
    this.tree.addFile(file, this.settings, true).syncMetadata(this.resolveMetadata(file));
    return true;
  }
  onMetadataChanged(file) {
    if (!this.isNote(file.extension))
      return false;
    const note = this.tree.getFromFileName(file.basename, this.settings);
    if (!note)
      return false;
    note.syncMetadata(this.resolveMetadata(file));
    this.tree.updateNoteFile(note, file);
    return true;
  }
  onFileDeleted(parsed) {
    if (!this.isNote(parsed.extension))
      return false;
    const note = this.tree.deleteByFileName(parsed.basename, this.settings);
    if (note == null ? void 0 : note.parent) {
      note.syncMetadata(void 0);
    }
    return true;
  }
  isAccessibleFrom(activeFile2) {
    if (!this.config.isSecret)
      return true;
    if (!activeFile2)
      return false;
    return activeFile2.path.startsWith(this.config.path);
  }
};

// src/modal/renameNoteModal.ts
var import_obsidian7 = require("obsidian");
var RenameNoteModal = class extends import_obsidian7.Modal {
  constructor(app, file, onRename) {
    super(app);
    this.file = file;
    this.onRename = onRename;
    this.modalEl.addClass("structured-rename-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("structured-rename-modal");
    contentEl.createEl("h2", { text: "Rename Note" });
    contentEl.createEl("h5", { text: `${this.file.basename}` });
    const inputContainer = contentEl.createDiv("structured-rename-input-container");
    this.newNameInput = inputContainer.createEl("input", {
      type: "text",
      value: this.file.basename,
      cls: "structured-rename-input",
      attr: { spellcheck: "false" }
    });
    setTimeout(() => {
      this.newNameInput.focus();
      this.newNameInput.setSelectionRange(
        this.newNameInput.value.length,
        this.newNameInput.value.length
      );
    }, 0);
    this.newNameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.rename();
      }
    });
    this.errorMessageEl = contentEl.createEl("p", {
      cls: "structured-rename-error",
      text: ""
    });
    new import_obsidian7.Setting(contentEl).addButton((btn) => {
      this.renameButton = btn.setButtonText("Rename").setCta().onClick(() => this.rename());
    });
  }
  async rename() {
    const newName = this.newNameInput.value;
    if (newName && newName !== this.file.basename) {
      if (await this.fileExists(newName)) {
        this.showError(`A file named "${newName}" already exists.`);
      } else {
        try {
          await this.onRename(newName);
          this.close();
        } catch (error) {
          this.showError(`Failed to rename: ${error.message}`);
        }
      }
    }
  }
  async fileExists(fileName) {
    const newPath = this.file.path.replace(this.file.name, fileName);
    return await this.app.vault.adapter.exists(newPath);
  }
  showError(message) {
    this.errorMessageEl.setText(message);
    this.errorMessageEl.style.display = "block";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/moveNote.ts
var import_obsidian8 = require("obsidian");
function moveNoteCommand(app, workspace) {
  return {
    id: "structured-tree-move-file",
    name: "Move file to vault",
    callback: () => moveNoteToVault(app, workspace)
  };
}
async function moveNotesToVault(app, workspace, files) {
  if (files.length === 0) {
    new import_obsidian8.Notice("No files selected");
    return;
  }
  const sourceVaults = files.map((file) => workspace.findVaultByParent(file.parent));
  if (sourceVaults.some((vault) => !vault)) {
    new import_obsidian8.Notice("Some files are not in structured vaults");
    return;
  }
  new SelectVaultModal(app, workspace, async (targetVault) => {
    if (!targetVault.folder) {
      new import_obsidian8.Notice("Target vault folder not found");
      return;
    }
    let successCount = 0;
    let failCount = 0;
    for (const file of files) {
      const sourceVault = workspace.findVaultByParent(file.parent);
      if (!sourceVault)
        continue;
      const normalizedTargetPath = (0, import_obsidian8.normalizePath)(`${targetVault.folder.path}/${file.name}`);
      try {
        await app.fileManager.renameFile(file, normalizedTargetPath);
        sourceVault.tree.deleteByFileName(file.basename, workspace.settings);
        const targetFile = app.vault.getAbstractFileByPath(normalizedTargetPath);
        if (targetFile) {
          targetVault.onFileCreated(targetFile);
          successCount++;
        }
      } catch (error) {
        failCount++;
      }
    }
    if (successCount > 0) {
      new import_obsidian8.Notice(`Moved ${successCount} files to ${targetVault.config.name}`);
    }
    if (failCount > 0) {
      new import_obsidian8.Notice(`Failed to move ${failCount} files`);
    }
  }).open();
}
async function moveNoteToVault(app, workspace, file) {
  const activeFile2 = file || app.workspace.getActiveFile();
  if (!activeFile2) {
    new import_obsidian8.Notice("No file is currently open");
    return;
  }
  const sourceVault = workspace.findVaultByParent(activeFile2.parent);
  if (!sourceVault) {
    new import_obsidian8.Notice("Current file is not in a structured vault");
    return;
  }
  new SelectVaultModal(app, workspace, async (targetVault) => {
    if (!targetVault.folder) {
      new import_obsidian8.Notice("Target vault folder not found");
      return;
    }
    const normalizedTargetPath = (0, import_obsidian8.normalizePath)(`${targetVault.folder.path}/${activeFile2.name}`);
    try {
      await app.fileManager.renameFile(activeFile2, normalizedTargetPath);
      sourceVault.tree.deleteByFileName(activeFile2.basename, workspace.settings);
      const targetFile = app.vault.getAbstractFileByPath(normalizedTargetPath);
      if (targetFile) {
        targetVault.onFileCreated(targetFile);
        new import_obsidian8.Notice(`Moved ${activeFile2.name} to ${targetVault.config.name}`);
      }
    } catch (error) {
      new import_obsidian8.Notice(`Failed to move file: ${error}`);
    }
  }).open();
}

// src/components/NoteComponent.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  child_ctx[35] = list;
  child_ctx[36] = i;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  let icon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "tree-item-icon collapse-icon");
      toggle_class(
        div,
        "is-collapsed",
        /*isCollapsed*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(icon_action = /*icon*/
          ctx[11].call(null, div)),
          listen(div, "click", stop_propagation(
            /*click_handler*/
            ctx[20]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*isCollapsed*/
      16) {
        toggle_class(
          div,
          "is-collapsed",
          /*isCollapsed*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "structured-tree-not-found");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*note*/
    ctx[0].children
  );
  const get_key = (ctx2) => (
    /*child*/
    ctx2[34].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "introstart",
            /*expandTransitionStart*/
            ctx[15]
          ),
          listen(
            div,
            "introend",
            /*introend_handler*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*note, vault, childrenFocus, childrenComponents*/
      101) {
        each_value = /*note*/
        ctx2[0].children;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let notecomponent;
  let updating_focusNotes;
  let child = (
    /*child*/
    ctx[34]
  );
  let current;
  function notecomponent_focusNotes_binding(value) {
    ctx[22](
      value,
      /*child*/
      ctx[34]
    );
  }
  const assign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[23](notecomponent, child)
  );
  const unassign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[23](null, child)
  );
  let notecomponent_props = {
    note: (
      /*child*/
      ctx[34]
    ),
    vault: (
      /*vault*/
      ctx[2]
    )
  };
  if (
    /*childrenFocus*/
    ctx[5][
      /*child*/
      ctx[34].name
    ] !== void 0
  ) {
    notecomponent_props.focusNotes = /*childrenFocus*/
    ctx[5][
      /*child*/
      ctx[34].name
    ];
  }
  notecomponent = new NoteComponent({ props: notecomponent_props });
  binding_callbacks.push(() => bind(notecomponent, "focusNotes", notecomponent_focusNotes_binding));
  assign_notecomponent();
  notecomponent.$on(
    "openNote",
    /*openNote_handler*/
    ctx[24]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(notecomponent.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(notecomponent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (child !== /*child*/
      ctx[34]) {
        unassign_notecomponent();
        child = /*child*/
        ctx[34];
        assign_notecomponent();
      }
      const notecomponent_changes = {};
      if (dirty[0] & /*note*/
      1)
        notecomponent_changes.note = /*child*/
        ctx[34];
      if (dirty[0] & /*vault*/
      4)
        notecomponent_changes.vault = /*vault*/
        ctx[2];
      if (!updating_focusNotes && dirty[0] & /*childrenFocus, note*/
      33) {
        updating_focusNotes = true;
        notecomponent_changes.focusNotes = /*childrenFocus*/
        ctx[5][
          /*child*/
          ctx[34].name
        ];
        add_flush_callback(() => updating_focusNotes = false);
      }
      notecomponent.$set(notecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      unassign_notecomponent();
      destroy_component(notecomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let t1_value = (
    /*note*/
    ctx[0].title + /*isRoot*/
    (ctx[1] && /*$showVaultPath*/
    ctx[10] ? ` (${/*vault*/
    ctx[2].config.name})` : "")
  );
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*note*/
    ctx[0].children.length > 0 && create_if_block_2(ctx)
  );
  let if_block1 = !/*note*/
  ctx[0].file && create_if_block_1(ctx);
  let if_block2 = (
    /*note*/
    ctx[0].children.length > 0 && !/*isCollapsed*/
    ctx[4] && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "tree-item-inner");
      attr(div1, "class", "tree-item-self is-clickable mod-collapsible");
      toggle_class(
        div1,
        "is-active",
        /*isActive*/
        ctx[9]
      );
      toggle_class(
        div1,
        "is-selected",
        /*isSelected*/
        ctx[7]
      );
      attr(div2, "class", "tree-item is-clickable");
      toggle_class(
        div2,
        "is-collapsed",
        /*isCollapsed*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[21](div1);
      append(div2, t3);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "click",
            /*handleClick*/
            ctx[12]
          ),
          listen(
            div1,
            "dblclick",
            /*handleDoubleClick*/
            ctx[13]
          ),
          listen(
            div1,
            "contextmenu",
            /*openMenu*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*note*/
        ctx2[0].children.length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty[0] & /*note, isRoot, $showVaultPath, vault*/
      1031) && t1_value !== (t1_value = /*note*/
      ctx2[0].title + /*isRoot*/
      (ctx2[1] && /*$showVaultPath*/
      ctx2[10] ? ` (${/*vault*/
      ctx2[2].config.name})` : "")))
        set_data(t1, t1_value);
      if (!/*note*/
      ctx2[0].file) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & /*isActive*/
      512) {
        toggle_class(
          div1,
          "is-active",
          /*isActive*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*isSelected*/
      128) {
        toggle_class(
          div1,
          "is-selected",
          /*isSelected*/
          ctx2[7]
        );
      }
      if (
        /*note*/
        ctx2[0].children.length > 0 && !/*isCollapsed*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*note, isCollapsed*/
          17) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*isCollapsed*/
      16) {
        toggle_class(
          div2,
          "is-collapsed",
          /*isCollapsed*/
          ctx2[4]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[21](null);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let isActive;
  let $selectedNotes;
  let $activeFile;
  let $showVaultPath;
  component_subscribe($$self, selectedNotes, ($$value) => $$invalidate(18, $selectedNotes = $$value));
  component_subscribe($$self, activeFile, ($$value) => $$invalidate(19, $activeFile = $$value));
  component_subscribe($$self, showVaultPath, ($$value) => $$invalidate(10, $showVaultPath = $$value));
  let { note } = $$props;
  let { isRoot = false } = $$props;
  let { vault } = $$props;
  let headerElement;
  let isCollapsed = true;
  const icon = function(node) {
    node.appendChild((0, import_obsidian9.getIcon)("right-triangle"));
  };
  onMount(() => {
    document.addEventListener("keydown", handleKeydown);
  });
  onDestroy(() => {
    document.removeEventListener("keydown", handleKeydown);
  });
  function openNoteFile(target) {
    if (note.file) {
      openFile(getPlugin().app, note.file, { openTarget: target });
    }
  }
  function createCurrentNote() {
    return __awaiter(this, void 0, void 0, function* () {
      const path = note.getPath(true);
      const plugin2 = getPlugin();
      const file = yield vault.createNote(path);
      openFile(plugin2.app, file);
      return file;
    });
  }
  function deleteCurrentNote() {
    const plugin2 = getPlugin();
    if (!note.file)
      return;
    this.app.fileManager.trashFile(note.file);
  }
  function openLookup() {
    const plugin2 = getPlugin();
    const initialPath = note.getPath(true) + ".";
    openLookupWithCurrentPath(plugin2.app, plugin2.workspace, initialPath, vault);
  }
  function openRenameModal() {
    if (!note.file)
      return;
    const plugin2 = getPlugin();
    new RenameNoteModal(
      plugin2.app,
      note.file,
      (newName) => __awaiter(this, void 0, void 0, function* () {
        yield vault.noteRenamer.renameNote(note.file, newName);
      })
    ).open();
  }
  const childrenFocus = {};
  const childrenComponents = {};
  function collapseAllButTop2() {
    if (!isRoot) {
      $$invalidate(4, isCollapsed = true);
    }
    Object.values(childrenComponents).forEach((child) => {
      if (child && typeof child.collapseAllButTop === "function") {
        try {
          child.collapseAllButTop();
        } catch (e) {
          console.warn("Failed to collapse child component", e);
        }
      }
    });
  }
  function handleKeydown(event) {
    if (event.key === "Escape" && $selectedNotes.length > 0) {
      set_store_value(selectedNotes, $selectedNotes = [], $selectedNotes);
    }
  }
  let isSelected = false;
  function handleClick(event) {
    if (event.ctrlKey || event.shiftKey) {
      if (!note.file)
        return;
      if (event.ctrlKey) {
        if ($selectedNotes.length === 0 && $activeFile) {
          const activeNote = vault.tree.flatten().find((n) => n.file === $activeFile);
          if (activeNote) {
            set_store_value(selectedNotes, $selectedNotes = [activeNote], $selectedNotes);
          }
        }
        if (isSelected) {
          set_store_value(selectedNotes, $selectedNotes = $selectedNotes.filter((n) => n !== note), $selectedNotes);
        } else {
          set_store_value(selectedNotes, $selectedNotes = [...$selectedNotes, note], $selectedNotes);
        }
      } else if (event.shiftKey) {
        if ($selectedNotes.length === 0 && $activeFile) {
          const activeNote = vault.tree.flatten().find((n) => n.file === $activeFile);
          if (activeNote) {
            const notes2 = vault.tree.flatten().filter((n) => n.file);
            const start2 = notes2.indexOf(activeNote);
            const end2 = notes2.indexOf(note);
            const range2 = notes2.slice(Math.min(start2, end2), Math.max(start2, end2) + 1);
            set_store_value(selectedNotes, $selectedNotes = range2, $selectedNotes);
            return;
          }
        }
        const lastSelected = $selectedNotes[$selectedNotes.length - 1];
        const notes = vault.tree.flatten().filter((n) => n.file);
        const start = notes.indexOf(lastSelected);
        const end = notes.indexOf(note);
        const range = notes.slice(Math.min(start, end), Math.max(start, end) + 1);
        set_store_value(selectedNotes, $selectedNotes = [.../* @__PURE__ */ new Set([...$selectedNotes, ...range])], $selectedNotes);
      }
    } else {
      set_store_value(selectedNotes, $selectedNotes = [], $selectedNotes);
      dispatcher("openNote", note);
      if (note.file) {
        openNoteFile(void 0);
      }
    }
    $$invalidate(4, isCollapsed = false);
  }
  function handleDoubleClick() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!note.file) {
        const file = yield createCurrentNote();
        $$invalidate(0, note.file = file, note);
        $$invalidate(0, note);
      }
    });
  }
  function openMenu(e) {
    const menu = new import_obsidian9.Menu();
    if ($selectedNotes.length > 1 && isSelected) {
      const validSelectedNotes = $selectedNotes.filter((n) => n.file);
      const validCount = validSelectedNotes.length;
      menu.addItem((item) => {
        item.setTitle(`Delete ${validCount} notes`).setIcon("trash").onClick(() => {
          const plugin2 = getPlugin();
          validSelectedNotes.forEach((note2) => {
            if (note2.file) {
              plugin2.app.fileManager.trashFile(note2.file);
            }
          });
          set_store_value(selectedNotes, $selectedNotes = [], $selectedNotes);
        });
      });
      menu.addItem((item) => {
        item.setTitle(`Move ${validCount} notes to vault`).setIcon("folder-input").onClick(() => {
          const plugin2 = getPlugin();
          const files = validSelectedNotes.map((n) => n.file).filter((f) => f !== null);
          moveNotesToVault(plugin2.app, plugin2.workspace, files);
        });
      });
      menu.showAtMouseEvent(e);
      return;
    }
    if (note.file) {
      menu.addItem((item) => {
        item.setTitle("Open in new tab").setIcon("lucide-file-plus").onClick(() => openNoteFile("new-tab"));
      });
      menu.addItem((item) => {
        item.setTitle("Open to the right").setIcon("lucide-separator-vertical").onClick(() => openNoteFile("new-leaf"));
      });
      if (isDesktopApp()) {
        menu.addItem((item) => {
          item.setTitle("Open in new window").setIcon("lucide-maximize").onClick(() => openNoteFile("new-window"));
        });
      }
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Rename note").setIcon("pencil").onClick(openRenameModal);
      });
      menu.addItem((item) => {
        item.setTitle("Move to Vault").setIcon("folder-input").onClick(() => {
          const plugin2 = getPlugin();
          moveNoteToVault(plugin2.app, plugin2.workspace, note.file);
        });
      });
      if (isDesktopApp()) {
        menu.addItem((item) => {
          item.setTitle("Show in system explorer").setIcon("external-link").onClick(() => showInSystemExplorer(getPlugin().app, note.file.path));
        });
      }
      menu.addSeparator();
    }
    if (!note.file) {
      menu.addItem((item) => {
        item.setTitle("Create current note").setIcon("create-new").onClick(createCurrentNote);
      });
    }
    menu.addItem((item) => {
      item.setTitle("Create new note").setIcon("plus").onClick(openLookup);
    });
    menu.addSeparator();
    if (note.file)
      menu.addItem((item) => {
        item.setTitle("Delete note").setIcon("trash").onClick(deleteCurrentNote);
      });
    menu.showAtMouseEvent(e);
  }
  let expandTransitionWaiter = Promise.resolve();
  let expandTransitionEnd;
  function expandTransitionStart() {
    expandTransitionWaiter = new Promise((resolve) => {
      $$invalidate(8, expandTransitionEnd = resolve);
    });
  }
  const focusNotes = (pathNotes) => __awaiter(void 0, void 0, void 0, function* () {
    const nextNote = pathNotes.shift();
    if (nextNote) {
      $$invalidate(4, isCollapsed = false);
      yield tick();
      const focusFN = childrenFocus[nextNote.name];
      if (!focusFN)
        return;
      if (pathNotes.length === 0)
        yield expandTransitionWaiter;
      focusFN(pathNotes);
    } else
      headerElement.scrollIntoView({ block: "center" });
  });
  const dispatcher = createEventDispatcher();
  const click_handler = () => {
    $$invalidate(4, isCollapsed = !isCollapsed);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerElement = $$value;
      $$invalidate(3, headerElement);
    });
  }
  function notecomponent_focusNotes_binding(value, child) {
    if ($$self.$$.not_equal(childrenFocus[child.name], value)) {
      childrenFocus[child.name] = value;
      $$invalidate(5, childrenFocus);
    }
  }
  function notecomponent_binding($$value, child) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      childrenComponents[child.name] = $$value;
      $$invalidate(6, childrenComponents);
    });
  }
  function openNote_handler(event) {
    bubble.call(this, $$self, event);
  }
  const introend_handler = () => {
    expandTransitionEnd();
  };
  $$self.$$set = ($$props2) => {
    if ("note" in $$props2)
      $$invalidate(0, note = $$props2.note);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("vault" in $$props2)
      $$invalidate(2, vault = $$props2.vault);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*note, $activeFile*/
    524289) {
      $:
        $$invalidate(9, isActive = note.file && $activeFile === note.file);
    }
    if ($$self.$$.dirty[0] & /*$selectedNotes, note*/
    262145) {
      $:
        $$invalidate(7, isSelected = $selectedNotes.includes(note));
    }
  };
  return [
    note,
    isRoot,
    vault,
    headerElement,
    isCollapsed,
    childrenFocus,
    childrenComponents,
    isSelected,
    expandTransitionEnd,
    isActive,
    $showVaultPath,
    icon,
    handleClick,
    handleDoubleClick,
    openMenu,
    expandTransitionStart,
    collapseAllButTop2,
    focusNotes,
    $selectedNotes,
    $activeFile,
    click_handler,
    div1_binding,
    notecomponent_focusNotes_binding,
    notecomponent_binding,
    openNote_handler,
    introend_handler
  ];
}
var NoteComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        note: 0,
        isRoot: 1,
        vault: 2,
        collapseAllButTop: 16,
        focusNotes: 17
      },
      null,
      [-1, -1]
    );
  }
  get collapseAllButTop() {
    return this.$$.ctx[16];
  }
  get focusNotes() {
    return this.$$.ctx[17];
  }
};
var NoteComponent_default = NoteComponent;

// src/components/MainComponent.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[8] = list;
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block2(key_1, ctx) {
  let first;
  let notecomponent;
  let vault = (
    /*vault*/
    ctx[7]
  );
  let current;
  const assign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[5](notecomponent, vault)
  );
  const unassign_notecomponent = () => (
    /*notecomponent_binding*/
    ctx[5](null, vault)
  );
  let notecomponent_props = {
    note: (
      /*vault*/
      ctx[7].tree.root
    ),
    isRoot: true,
    vault: (
      /*vault*/
      ctx[7]
    )
  };
  notecomponent = new NoteComponent_default({ props: notecomponent_props });
  assign_notecomponent();
  notecomponent.$on(
    "openNote",
    /*onOpenNote*/
    ctx[2]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(notecomponent.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(notecomponent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (vault !== /*vault*/
      ctx[7]) {
        unassign_notecomponent();
        vault = /*vault*/
        ctx[7];
        assign_notecomponent();
      }
      const notecomponent_changes = {};
      if (dirty & /*$structuredVaultList*/
      2)
        notecomponent_changes.note = /*vault*/
        ctx[7].tree.root;
      if (dirty & /*$structuredVaultList*/
      2)
        notecomponent_changes.vault = /*vault*/
        ctx[7];
      notecomponent.$set(notecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      unassign_notecomponent();
      destroy_component(notecomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = (
    /*$structuredVaultList*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*vault*/
    ctx2[7].config.name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$structuredVaultList, children, onOpenNote*/
      7) {
        each_value = /*$structuredVaultList*/
        ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $structuredVaultList;
  component_subscribe($$self, structuredVaultList, ($$value) => $$invalidate(1, $structuredVaultList = $$value));
  const children2 = {};
  let pendingOpenNote = null;
  function focusTo(vault, note) {
    if (pendingOpenNote === note) {
      pendingOpenNote = null;
      return;
    }
    const vaultComponent = children2[vault.config.name];
    if (!vaultComponent)
      return;
    const pathNotes = note.getPathNotes();
    pathNotes.shift();
    vaultComponent.focusNotes(pathNotes);
  }
  function onOpenNote(e) {
    pendingOpenNote = e.detail;
  }
  function collapseAllButTop2() {
    Object.values(children2).forEach((child) => child.collapseAllButTop());
  }
  function notecomponent_binding($$value, vault) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      children2[vault.config.name] = $$value;
      $$invalidate(0, children2);
    });
  }
  return [
    children2,
    $structuredVaultList,
    onOpenNote,
    focusTo,
    collapseAllButTop2,
    notecomponent_binding
  ];
}
var MainComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { focusTo: 3, collapseAllButTop: 4 });
  }
  get focusTo() {
    return this.$$.ctx[3];
  }
  get collapseAllButTop() {
    return this.$$.ctx[4];
  }
};
var MainComponent_default = MainComponent;

// src/icons.ts
var import_obsidian10 = require("obsidian");
var structuredActivityBarName = "structured-activity-bar";
function getStructuredActivityBarIcon(svgPath) {
  return `<svg width="100px" height="100px" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" fill="currentColor" stroke="currentColor">${svgPath}</svg>`;
}
var structuredActivityBarIconPath = `<path d="m62.094 52.941h-3.2695c-2.1445 0-4.1523-0.57422-5.8828-1.5742v26.574c0 3.25 2.6328 5.8828 5.8828 5.8828h3.2695c1.3359-5.8945 6.6094-10.293 12.906-10.293 7.3086 0 13.234 5.9219 13.234 13.234 0 7.3086-5.9258 13.234-13.234 13.234-6.2969 0-11.57-4.3984-12.906-10.293h-3.2695c-6.5 0-11.766-5.2695-11.766-11.766v-55.883c0-3.25-2.6328-5.8828-5.8828-5.8828h-3.2695c-1.3359 5.8945-6.6094 10.293-12.906 10.293-7.3086 0-13.234-5.9219-13.234-13.234 0-7.3086 5.9258-13.234 13.234-13.234 6.2969 0 11.57 4.3984 12.906 10.293h3.2695c6.5 0 11.766 5.2695 11.766 11.766v19.117c0 3.25 2.6328 5.8828 5.8828 5.8828h3.2695c1.3359-5.8945 6.6094-10.293 12.906-10.293 7.3086 0 13.234 5.9258 13.234 13.234s-5.9258 13.234-13.234 13.234c-6.2969 0-11.57-4.3984-12.906-10.293zm-37.094-32.352c4.0625 0 7.3516-3.293 7.3516-7.3555 0-4.0586-3.2891-7.3516-7.3516-7.3516s-7.3516 3.293-7.3516 7.3516c0 4.0625 3.2891 7.3555 7.3516 7.3555zm50 73.527c4.0625 0 7.3516-3.293 7.3516-7.3516 0-4.0625-3.2891-7.3555-7.3516-7.3555s-7.3516 3.293-7.3516 7.3555c0 4.0586 3.2891 7.3516 7.3516 7.3516zm0-36.766c4.0625 0 7.3516-3.2891 7.3516-7.3516s-3.2891-7.3516-7.3516-7.3516-7.3516 3.2891-7.3516 7.3516 3.2891 7.3516 7.3516 7.3516z"/>`;
var structuredActivityBarIcon = getStructuredActivityBarIcon(
  structuredActivityBarIconPath
);
var IconSuggestModal = class extends import_obsidian10.SuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelectCallback = onSelect;
  }
  getSuggestions(query) {
    const allIcons = (0, import_obsidian10.getIconIds)();
    if (!query)
      return allIcons;
    return allIcons.filter((icon) => icon.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(value, el) {
    (0, import_obsidian10.setIcon)(el, value);
    el.style.width = "fit-content";
    el.style.height = "fit-content";
    el.style.display = "flex";
    el.style.alignItems = "center";
    this.resultContainerEl.style.display = "flex";
    this.resultContainerEl.style.flexFlow = "row wrap";
  }
  onChooseSuggestion(iconId, evt) {
    this.onSelectCallback(iconId);
  }
};
function attachIconModal(button, onSelect) {
  const modal = new IconSuggestModal(this.app, onSelect);
  const modalEl = modal.modalEl;
  const buttonRect = button.buttonEl.getBoundingClientRect();
  const width = 248;
  modalEl.style.width = `${248}px`;
  modalEl.style.height = "240px";
  modalEl.style.position = "absolute";
  modalEl.style.top = `${buttonRect.bottom}px`;
  modalEl.style.left = `${buttonRect.right - width}px`;
  modalEl.style.transform = "none";
  modal.open();
}

// src/view.ts
var VIEW_TYPE_STRUCTURED = "structured-tree-view";
var StructuredView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.icon = structuredActivityBarName;
    this.icon = this.plugin.settings.pluginIcon;
  }
  getViewType() {
    return VIEW_TYPE_STRUCTURED;
  }
  getDisplayText() {
    return "Structured Tree";
  }
  async onOpen() {
    plugin.set(this.plugin);
    this.component = new MainComponent_default({
      target: this.contentEl
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  collapseAllButTop() {
    if (this.component) {
      this.component.collapseAllButTop();
    }
  }
};

// src/settings.ts
var import_obsidian15 = require("obsidian");

// src/modal/addVaultModal.ts
var import_obsidian13 = require("obsidian");

// src/modal/folderSuggester.ts
var import_obsidian12 = require("obsidian");
var FolderSuggester = class extends import_obsidian12.PopoverSuggest {
  constructor(app, inputEl, onSelected) {
    super(app);
    this.app = app;
    this.inputEl = inputEl;
    this.onSelected = onSelected;
    this.onInputChange = () => {
      const suggestionList = this.getSuggestions(this.inputEl.value);
      if (suggestionList.length === 0) {
        this.close();
        return;
      }
      this.suggestions.setSuggestions(suggestionList);
      this.open();
      this.setAutoDestroy(this.inputEl);
      this.suggestEl.classList.add("suggestion-width-dynamic");
      this.suggestEl.style.setProperty("--suggestion-width", `${this.inputEl.offsetWidth}px`);
      const loc = this.inputEl.getBoundingClientRect();
      this.reposition({
        left: loc.left,
        right: loc.right,
        top: loc.top,
        bottom: loc.top + this.inputEl.offsetHeight
      });
    };
    inputEl.addEventListener("input", this.onInputChange);
    inputEl.addEventListener("focus", this.onInputChange);
    inputEl.addEventListener("blur", () => this.close());
    this.suggestEl.on("mousedown", ".suggestion-item", (e) => e.preventDefault());
    this.suggestEl.classList.add("structured-folder-suggest");
  }
  getSuggestions(query) {
    const queryLowercase = query.toLowerCase();
    return this.app.vault.getAllLoadedFiles().filter(
      (file) => file instanceof import_obsidian12.TFolder && file.path.toLowerCase().includes(queryLowercase)
    );
  }
  renderSuggestion(value, el) {
    el.createDiv({
      text: value.path
    });
  }
  selectSuggestion(value, evt) {
    this.inputEl.value = value.path;
    this.close();
    this.onSelected(value);
  }
};

// src/modal/addVaultModal.ts
var AddVaultModal = class extends import_obsidian13.Modal {
  constructor(app, onSubmit, existingVault) {
    super(app);
    this.onSubmit = onSubmit;
    this.propertySettings = {};
    this.isSecret = false;
    this.propertiesEnabled = false;
    if (existingVault) {
      this.isSecret = existingVault.isSecret || false;
      this.folder = app.vault.getAbstractFileByPath(existingVault.path);
      this.originalVaultName = existingVault.name;
      if (existingVault.properties) {
        this.propertySettings = existingVault.properties;
        this.propertiesEnabled = true;
      }
    }
  }
  generateName({ path, name }) {
    if (path === "/")
      return "root";
    return name;
  }
  onOpen() {
    const { contentEl } = this;
    const headerEl = contentEl.createDiv("modal-header");
    new import_obsidian13.Setting(headerEl).setHeading().setName(this.folder ? "Edit Vault" : "Add Vault").addButton((btn) => {
      btn.setCta().setButtonText(this.folder ? "Save" : "Add").onClick(() => this.saveVault());
    });
    const contentContainer = contentEl.createDiv("modal-content");
    this.addBasicSettings(contentContainer);
    this.addPropertySettings(contentContainer);
  }
  saveVault() {
    const name = this.nameText.getValue();
    if (!this.folder || name.trim().length === 0) {
      new import_obsidian13.Notice("Please specify Vault Path and Vault Name");
      return;
    }
    const config = {
      path: this.folder.path,
      name,
      isSecret: this.isSecret
    };
    if (this.propertiesEnabled && Object.keys(this.propertySettings).length > 0) {
      config.properties = this.propertySettings;
    }
    if (this.onSubmit(config)) {
      this.close();
    }
  }
  addBasicSettings(containerEl) {
    new import_obsidian13.Setting(containerEl).setName("Vault Name").addText((text2) => {
      var _a;
      this.nameText = text2;
      if (this.folder) {
        text2.setValue((_a = this.originalVaultName) != null ? _a : this.generateName(this.folder));
      }
    });
    new import_obsidian13.Setting(containerEl).setName("Vault Path").addText((text2) => {
      if (this.folder) {
        text2.setValue(this.folder.path);
      }
      new FolderSuggester(this.app, text2.inputEl, (newFolder) => {
        const currentName = this.nameText.getValue();
        if (!this.originalVaultName && (currentName.length === 0 || this.folder && currentName === this.generateName(this.folder))) {
          this.nameText.setValue(this.generateName(newFolder));
        }
        this.folder = newFolder;
      });
    });
    new import_obsidian13.Setting(containerEl).setName("Secret Vault").setDesc("Content will be hidden from lookup results").addToggle((toggle) => {
      toggle.setValue(this.isSecret).onChange((value) => {
        this.isSecret = value;
      });
    });
  }
  addPropertySettings(containerEl) {
    containerEl.createEl("h3", { text: "Property Settings" });
    const propertySettingsWrapper = containerEl.createDiv("property-settings-wrapper");
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Override Property Settings").setDesc("Enable to override global property settings for this vault").addToggle((toggle) => {
      toggle.setValue(this.propertiesEnabled).onChange((value) => {
        var _a;
        this.propertiesEnabled = value;
        if (!value) {
          this.propertySettings = {};
        }
        (_a = propertySettingsWrapper.children[1]) == null ? void 0 : _a.remove();
        if (value) {
          this.displayPropertySettings(propertySettingsWrapper);
        }
      });
    });
    if (this.propertiesEnabled) {
      this.displayPropertySettings(propertySettingsWrapper);
    }
  }
  displayPropertySettings(containerEl) {
    const propertySettingsWrapper = containerEl.createDiv("property-settings-wrapper");
    const disclaimer = propertySettingsWrapper.createEl("div", {
      cls: "structured-experimental-disclaimer"
    });
    disclaimer.createSpan({ text: "\u26A0\uFE0F ", cls: "structured-experimental-icon" });
    disclaimer.createSpan({
      text: "Please reload or restart Obsidian after changing these settings",
      cls: "structured-experimental-text"
    });
    if (!this.propertiesEnabled)
      return;
    let generateIdToggle;
    let generateTitleToggle;
    let generateDescToggle;
    let generateTagsToggle;
    let generateCreatedToggle;
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Auto-generate Properties").setHeading().setDesc("Generate properties for new files").addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.propertySettings.autoGenerateFrontmatter) != null ? _a : false).onChange((value) => {
        this.propertySettings.autoGenerateFrontmatter = value;
        if (!value) {
          this.propertySettings.generateId = false;
          this.propertySettings.generateTitle = false;
          this.propertySettings.generateDesc = false;
          this.propertySettings.generateTags = false;
          this.propertySettings.generateCreated = false;
          generateIdToggle.setValue(false);
          generateTitleToggle.setValue(false);
          generateDescToggle.setValue(false);
          generateTagsToggle.setValue(false);
          generateCreatedToggle.setValue(false);
        }
        generateIdToggle.setDisabled(!value);
        generateTitleToggle.setDisabled(!value);
        generateDescToggle.setDisabled(!value);
        generateTagsToggle.setDisabled(!value);
        generateCreatedToggle.setDisabled(!value);
      });
    });
    propertySettingsWrapper.createDiv("setting-item-separator");
    const handleDisabledToggleClick = (toggle, settingName) => {
      if (toggle.disabled) {
        new import_obsidian13.Notice(`Enable "Auto-generate Properties" to use ${settingName}`);
      }
    };
    new import_obsidian13.Setting(propertySettingsWrapper).setName("ID Property").setDesc("Generate a unique ID for new files").addToggle((toggle) => {
      var _a;
      generateIdToggle = toggle;
      toggle.setValue((_a = this.propertySettings.generateId) != null ? _a : false).setDisabled(!this.propertySettings.autoGenerateFrontmatter).onChange((value) => {
        this.propertySettings.generateId = value;
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "ID Property")
      );
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Title Property").setDesc("Generate title property for new files").addToggle((toggle) => {
      var _a;
      generateTitleToggle = toggle;
      toggle.setValue((_a = this.propertySettings.generateTitle) != null ? _a : false).setDisabled(!this.propertySettings.autoGenerateFrontmatter).onChange((value) => {
        this.propertySettings.generateTitle = value;
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Title Property")
      );
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Description Property").setDesc("Generate description property for new files").addToggle((toggle) => {
      var _a;
      generateDescToggle = toggle;
      toggle.setValue((_a = this.propertySettings.generateDesc) != null ? _a : false).setDisabled(!this.propertySettings.autoGenerateFrontmatter).onChange((value) => {
        this.propertySettings.generateDesc = value;
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Description Property")
      );
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Created Date Property").setDesc("Generate created date property for new files").addToggle((toggle) => {
      var _a;
      generateCreatedToggle = toggle;
      toggle.setValue((_a = this.propertySettings.generateCreated) != null ? _a : false).setDisabled(!this.propertySettings.autoGenerateFrontmatter).onChange((value) => {
        this.propertySettings.generateCreated = value;
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Created Date Property")
      );
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Tags Property").setDesc("Generate tags property for new files").addToggle((toggle) => {
      var _a;
      generateTagsToggle = toggle;
      toggle.setValue((_a = this.propertySettings.generateTags) != null ? _a : false).setDisabled(!this.propertySettings.autoGenerateFrontmatter).onChange((value) => {
        this.propertySettings.generateTags = value;
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Tags Property")
      );
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Created Date Format").setDesc("Choose the format for the created date").addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("yyyy-mm-dd", "YYYY-MM-DD").addOption("unix", "Unix (Milliseconds)").setValue((_a = this.propertySettings.createdFormat) != null ? _a : "yyyy-mm-dd").onChange((value) => {
        this.propertySettings.createdFormat = value;
      });
    });
    propertySettingsWrapper.createEl("h4", { text: "Property Keys" });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("ID Key").setDesc("Property to use for the note ID").addText((text2) => {
      var _a;
      text2.setPlaceholder("id").setValue((_a = this.propertySettings.idKey) != null ? _a : "").onChange((value) => {
        this.propertySettings.idKey = value.trim();
      });
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Title Key").setDesc("Property to use for the note title").addText((text2) => {
      var _a;
      text2.setPlaceholder("title").setValue((_a = this.propertySettings.titleKey) != null ? _a : "").onChange((value) => {
        this.propertySettings.titleKey = value.trim();
      });
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Description Key").setDesc("Property to use for note description").addText((text2) => {
      var _a;
      text2.setPlaceholder("desc").setValue((_a = this.propertySettings.descKey) != null ? _a : "").onChange((value) => {
        this.propertySettings.descKey = value.trim();
      });
    });
    new import_obsidian13.Setting(propertySettingsWrapper).setName("Created Key").setDesc("Property to use for note creation date").addText((text2) => {
      var _a;
      text2.setPlaceholder("created").setValue((_a = this.propertySettings.createdKey) != null ? _a : "").onChange((value) => {
        this.propertySettings.createdKey = value.trim();
      });
    });
  }
  addSubmitButton(containerEl) {
    new import_obsidian13.Setting(containerEl).addButton((btn) => {
      btn.setCta().setButtonText(this.folder ? "Save" : "Add").onClick(() => {
        const name = this.nameText.getValue();
        if (!this.folder || name.trim().length === 0) {
          new import_obsidian13.Notice("Please specify Vault Path and Vault Name");
          return;
        }
        const config = {
          path: this.folder.path,
          name,
          isSecret: this.isSecret
        };
        if (this.propertiesEnabled && Object.keys(this.propertySettings).length > 0) {
          config.properties = this.propertySettings;
        }
        if (this.onSubmit(config)) {
          this.close();
        }
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/modal/confirmationModal.ts
var import_obsidian14 = require("obsidian");
var ConfirmationModal = class extends import_obsidian14.Modal {
  constructor(app, title, message, confirmText, cancelText, onResult) {
    super(app);
    this.titleEl.setText(title);
    this.message = message;
    this.confirmText = confirmText;
    this.cancelText = cancelText;
    this.result = onResult;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(this.message);
    new import_obsidian14.Setting(contentEl).addButton(
      (btn) => btn.setButtonText(this.confirmText).setCta().onClick(() => {
        this.result(true);
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText(this.cancelText).onClick(() => {
        this.result(false);
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  vaultList: [
    {
      name: "root",
      path: "/"
    }
  ],
  autoReveal: true,
  customResolver: false,
  customGraph: false,
  enableCanvasSupport: false,
  hierarchySeparator: ".",
  autoGenerateFrontmatter: true,
  generateTags: false,
  generateId: false,
  generateTitle: true,
  generateDesc: true,
  generateCreated: false,
  idKey: "id",
  titleKey: "title",
  descKey: "desc",
  createdKey: "created",
  createdFormat: "yyyy-mm-dd",
  fuzzySearchFileNameWeight: 0.6,
  fuzzySearchThreshold: 0.2,
  excludedPaths: [],
  pluginIcon: structuredActivityBarName
};
var SettingTab = /* @__PURE__ */ ((SettingTab2) => {
  SettingTab2["General"] = "General";
  SettingTab2["Properties"] = "Properties";
  SettingTab2["Lookup"] = "Lookup";
  SettingTab2["Vaults"] = "Vaults";
  SettingTab2["Experimental"] = "Experimental";
  return SettingTab2;
})(SettingTab || {});
var StructuredTreeSettingTab = class extends import_obsidian15.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.activeTab = "General" /* General */;
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const tabContainer = containerEl.createDiv("settings-tab-container");
    Object.values(SettingTab).forEach((tab) => {
      const tabButton = tabContainer.createDiv("settings-tab");
      tabButton.textContent = tab;
      if (this.activeTab === tab) {
        tabButton.addClass("active");
      }
      tabButton.addEventListener("click", () => {
        this.activeTab = tab;
        this.display();
      });
    });
    const contentContainer = containerEl.createDiv("settings-tab-content");
    switch (this.activeTab) {
      case "General" /* General */:
        this.displayGeneralSettings(contentContainer);
        break;
      case "Properties" /* Properties */:
        this.displayPropertySettings(contentContainer);
        break;
      case "Lookup" /* Lookup */:
        this.displayLookupSettings(contentContainer);
        break;
      case "Vaults" /* Vaults */:
        this.displayVaultSettings(contentContainer);
        break;
      case "Experimental" /* Experimental */:
        this.displayExperimentalSettings(contentContainer);
        break;
    }
  }
  displayGeneralSettings(containerEl) {
    containerEl.empty();
    new import_obsidian15.Setting(containerEl).setName("Plugin Icon").setDesc("Choose an icon for the plugin.").addExtraButton(
      (button) => button.setDisabled(false).setIcon(this.plugin.settings.pluginIcon).setTooltip(this.plugin.settings.pluginIcon)
    ).addButton(
      (button) => button.setButtonText("Set Icon").onClick((iconId) => {
        attachIconModal(button, (iconId2) => {
          if (!iconId2)
            return;
          this.plugin.settings.pluginIcon = iconId2;
          this.plugin.saveSettings().then(() => {
            this.plugin.updateRibbonIcon();
            this.plugin.updateViewLeafIcon();
            this.display();
            this.updateIconSetButton(button);
          });
        });
      }).then(() => this.updateIconSetButton(button))
    );
    new import_obsidian15.Setting(containerEl).setName("Auto Reveal").setDesc("Automatically reveal active file in Structured Tree").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoReveal).onChange(async (value) => {
        this.plugin.settings.autoReveal = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian15.Setting(containerEl).setName("Custom Resolver").setDesc(
      "Use custom resolver to resolve ref/embed and link. (Please reopen or reload editor after changing)"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.customResolver).onChange(async (value) => {
        this.plugin.settings.customResolver = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian15.Setting(containerEl).setName("Hierarchy Separator").setDesc("Characters used to separate hierarchy levels. Max 2 characters.").addText((text2) => {
      text2.setPlaceholder(".").setValue(this.plugin.settings.hierarchySeparator).onChange(async (value) => {
        const separator = value.slice(0, 2);
        this.plugin.settings.hierarchySeparator = separator;
        text2.setValue(separator);
        await this.plugin.saveSettings();
      });
    });
  }
  displayPropertySettings(containerEl) {
    let generateIdToggle;
    let generateTitleToggle;
    let generateDescToggle;
    let generateTagsToggle;
    let generateCreatedToggle;
    new import_obsidian15.Setting(containerEl).setName("Auto-generate Properties").setHeading().setDesc("Generate properties for new files").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.autoGenerateFrontmatter = value;
        if (!value) {
          this.plugin.settings.generateId = false;
          this.plugin.settings.generateTags = false;
          generateIdToggle.setValue(false);
          generateTitleToggle.setValue(false);
          generateDescToggle.setValue(false);
          generateTagsToggle.setValue(false);
          generateCreatedToggle.setValue(false);
          generateCreatedToggle.setValue(false);
        }
        generateIdToggle.setDisabled(!value);
        generateTitleToggle.setDisabled(!value);
        generateTagsToggle.setDisabled(!value);
        generateTagsToggle.setDisabled(!value);
        generateDescToggle.setDisabled(!value);
        generateCreatedToggle.setDisabled(!value);
        await this.plugin.saveSettings();
      });
    });
    const handleDisabledToggleClick = (toggle, settingName) => {
      if (toggle.disabled) {
        new import_obsidian15.Notice(`Enable "Auto-generate Properties" to use ${settingName}`);
      }
    };
    new import_obsidian15.Setting(containerEl).setName("ID Property").setDesc("Generate a 23 character long, unique alphanumeric ID for new files").addToggle((toggle) => {
      generateIdToggle = toggle;
      toggle.setValue(this.plugin.settings.generateId).setDisabled(!this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.generateId = value;
        await this.plugin.saveSettings();
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "ID Property")
      );
    });
    new import_obsidian15.Setting(containerEl).setName("Title Property").setDesc("Generate a title property for new files").addToggle((toggle) => {
      generateTitleToggle = toggle;
      toggle.setValue(this.plugin.settings.generateTitle).setDisabled(!this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.generateTitle = value;
        await this.plugin.saveSettings();
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Title Property")
      );
    });
    new import_obsidian15.Setting(containerEl).setName("Description Property").setDesc("Generate a description property for new files").addToggle((toggle) => {
      generateDescToggle = toggle;
      toggle.setValue(this.plugin.settings.generateDesc).setDisabled(!this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.generateDesc = value;
        await this.plugin.saveSettings();
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Description Property")
      );
    });
    new import_obsidian15.Setting(containerEl).setName("Created Date Property").setDesc("Generate a property that stores the created date of the new file").addToggle((toggle) => {
      generateCreatedToggle = toggle;
      toggle.setValue(this.plugin.settings.generateCreated).setDisabled(!this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.generateCreated = value;
        await this.plugin.saveSettings();
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Created Date Property")
      );
    });
    new import_obsidian15.Setting(containerEl).setName("Tag Property").setDesc("Generate tag property for native Obsidian tags").addToggle((toggle) => {
      generateTagsToggle = toggle;
      toggle.setValue(this.plugin.settings.generateTags).setDisabled(!this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {
        this.plugin.settings.generateTags = value;
        await this.plugin.saveSettings();
      });
      toggle.toggleEl.addEventListener(
        "click",
        () => handleDisabledToggleClick(toggle, "Tags Property")
      );
    });
    containerEl.createEl("h4", { text: "Property Keys" });
    new import_obsidian15.Setting(containerEl).setName("ID Key").setDesc("Property to use for the note ID").addText(
      (text2) => text2.setPlaceholder("id").setValue(this.plugin.settings.idKey).onChange(async (value) => {
        this.plugin.settings.idKey = value.trim() || DEFAULT_SETTINGS.idKey;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("Title Key").setDesc("Property to use for the note title in the Tree and Lookup").addText(
      (text2) => text2.setPlaceholder("title").setValue(this.plugin.settings.titleKey).onChange(async (value) => {
        this.plugin.settings.titleKey = value.trim() || DEFAULT_SETTINGS.titleKey;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("Description Key").setDesc("Property to use for note description in Lookup").addText(
      (text2) => text2.setPlaceholder("desc").setValue(this.plugin.settings.descKey).onChange(async (value) => {
        this.plugin.settings.descKey = value.trim() || DEFAULT_SETTINGS.descKey;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("Created Key").setDesc("Property to use for note creation date").addText(
      (text2) => text2.setPlaceholder("created").setValue(this.plugin.settings.createdKey).onChange(async (value) => {
        this.plugin.settings.createdKey = value.trim() || DEFAULT_SETTINGS.createdKey;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("Created Date Format").setDesc("Choose the format for the created date").addDropdown((dropdown) => {
      dropdown.addOption("yyyy-mm-dd", "YYYY-MM-DD").addOption("unix", "Unix (Milliseconds)").setValue(this.plugin.settings.createdFormat).onChange(async (value) => {
        this.plugin.settings.createdFormat = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian15.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Reset Property Keys").onClick(async () => {
        const confirmed = await new Promise((resolve) => {
          const modal = new ConfirmationModal(
            this.app,
            "Reset Property Keys",
            "This will reset all property keys to their default values. Are you sure you want to continue?",
            "Reset",
            "Cancel",
            (result) => resolve(result)
          );
          modal.open();
        });
        if (confirmed) {
          this.plugin.settings.idKey = DEFAULT_SETTINGS.idKey;
          this.plugin.settings.titleKey = DEFAULT_SETTINGS.titleKey;
          this.plugin.settings.descKey = DEFAULT_SETTINGS.descKey;
          this.plugin.settings.createdKey = DEFAULT_SETTINGS.createdKey;
          this.plugin.settings.createdFormat = DEFAULT_SETTINGS.createdFormat;
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian15.Notice("Property keys have been reset to default values.");
        }
      })
    );
  }
  displayLookupSettings(containerEl) {
    new import_obsidian15.Setting(containerEl).setName("Excluded Paths").setDesc(
      "Paths that match these patterns will be less noticeable in lookup results. Use * as a wildcard."
    ).addTextArea(
      (text2) => text2.setPlaceholder("archive.*\nold/*").setValue(this.plugin.settings.excludedPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedPaths = value.split("\n").filter((line) => line.trim() !== "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("File Name Weight").setDesc("How important is the file name when searching (0-1)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.fuzzySearchFileNameWeight).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fuzzySearchFileNameWeight = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).setName("Search Threshold").setDesc("How exact the match needs to be (0-1). Lower values require more exact matches").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.fuzzySearchThreshold).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.fuzzySearchThreshold = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian15.Setting(containerEl).addButton(
      (btn) => btn.setButtonText("Reset Lookup Settings").onClick(async () => {
        const confirmed = await new Promise((resolve) => {
          const modal = new ConfirmationModal(
            this.app,
            "Reset Lookup Settings",
            "This will reset file name weight and search threshold to their default values. Are you sure you want to continue?",
            "Reset",
            "Cancel",
            (result) => resolve(result)
          );
          modal.open();
        });
        if (confirmed) {
          this.plugin.settings.fuzzySearchFileNameWeight = DEFAULT_SETTINGS.fuzzySearchFileNameWeight;
          this.plugin.settings.fuzzySearchThreshold = DEFAULT_SETTINGS.fuzzySearchThreshold;
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian15.Notice("Lookup settings have been reset.");
        }
      })
    );
  }
  displayVaultSettings(containerEl) {
    const vaultList = containerEl.createDiv("vault-list");
    for (const vault of this.plugin.settings.vaultList) {
      const vaultContainer = vaultList.createDiv("vault-container");
      new import_obsidian15.Setting(vaultContainer).setName(vault.name).setDesc(
        createFragment((el) => {
          el.createSpan({ text: vault.path });
          if (vault.properties) {
            el.createSpan({
              cls: "vault-custom-properties",
              attr: { "aria-label": "Has custom property settings" }
            }).createSpan({ text: "\u2699\uFE0F" });
          }
        })
      ).addExtraButton((btn) => {
        btn.setIcon("pencil").setTooltip("Edit vault").onClick(() => {
          new AddVaultModal(
            this.app,
            (newConfig) => {
              const index = this.plugin.settings.vaultList.indexOf(vault);
              this.plugin.settings.vaultList[index] = newConfig;
              this.plugin.saveSettings();
              this.display();
              return true;
            },
            vault
          ).open();
        });
      }).addExtraButton((btn) => {
        btn.setIcon("trash").setTooltip("Delete vault").onClick(() => {
          const index = this.plugin.settings.vaultList.indexOf(vault);
          this.plugin.settings.vaultList.splice(index, 1);
          this.plugin.saveSettings();
          this.display();
        });
      });
    }
    new import_obsidian15.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Add Vault").onClick(() => {
        new AddVaultModal(this.app, (config) => {
          const list = this.plugin.settings.vaultList;
          const nameLowecase = config.name.toLowerCase();
          if (list.find(({ name }) => name.toLowerCase() === nameLowecase)) {
            new import_obsidian15.Notice("Vault with same name already exist");
            return false;
          }
          if (list.find(({ path }) => path === config.path)) {
            new import_obsidian15.Notice("Vault with same path already exist");
            return false;
          }
          list.push(config);
          this.plugin.saveSettings().then(() => this.display());
          return true;
        }).open();
      });
    });
  }
  displayExperimentalSettings(containerEl) {
    const disclaimer = containerEl.createEl("div", {
      cls: "structured-experimental-disclaimer"
    });
    disclaimer.createSpan({ text: "\u26A0\uFE0F ", cls: "structured-experimental-icon" });
    disclaimer.createSpan({
      text: "These features are experimental and not completed yet. Expect bugs if you use them.",
      cls: "structured-experimental-text"
    });
    new import_obsidian15.Setting(containerEl).setName("Enable Canvas Support").setDesc("Enable support for displaying .canvas files in the tree").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableCanvasSupport).onChange(async (value) => {
        this.plugin.settings.enableCanvasSupport = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian15.Setting(containerEl).setName("Custom Graph Engine").setDesc(
      "Use custom graph engine to render graph. (Please reopen or reload editor after changing)"
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.customGraph).onChange(async (value) => {
        this.plugin.settings.customGraph = value;
        await this.plugin.saveSettings();
      });
    });
  }
  hide() {
    super.hide();
    this.plugin.onRootFolderChanged();
    this.plugin.configureCustomResolver();
    this.plugin.configureCustomGraph();
  }
  updateIconSetButton(button) {
    if (this.plugin.settings.pluginIcon == DEFAULT_SETTINGS.pluginIcon) {
      return;
    }
    button.setButtonText("Reset Icon").onClick(() => {
      this.plugin.settings.pluginIcon = DEFAULT_SETTINGS.pluginIcon;
      this.plugin.saveSettings().then(() => {
        this.plugin.updateRibbonIcon();
        this.plugin.updateViewLeafIcon();
        this.display();
      });
    });
  }
};

// src/path.ts
var lastSeparatorRegex = /[/\\](?!.*[/\\])/g;
var lastPeriodRegex = /\.(?!.*\.)/g;
function parsePath(path) {
  const pathComponent = path.split(lastSeparatorRegex);
  let dir = "";
  let name;
  if (pathComponent.length == 2)
    [dir, name] = pathComponent;
  else
    [name] = pathComponent;
  const nameComponent = name.split(lastPeriodRegex);
  const basename = nameComponent[0];
  let extension = "";
  if (nameComponent.length > 1)
    extension = nameComponent[1];
  return {
    dir,
    name,
    basename,
    extension
  };
}

// src/engine/structuredWorkspace.ts
var import_obsidian16 = require("obsidian");

// node_modules/github-slugger/regex.js
var regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;

// node_modules/github-slugger/index.js
var own = Object.hasOwnProperty;
var BananaSlug = class {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences;
    this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(value, maintainCase) {
    const self = this;
    let result = slug(value, maintainCase === true);
    const originalSlug = result;
    while (own.call(self.occurrences, result)) {
      self.occurrences[originalSlug]++;
      result = originalSlug + "-" + self.occurrences[originalSlug];
    }
    self.occurrences[result] = 0;
    return result;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
};
function slug(value, maintainCase) {
  if (typeof value !== "string")
    return "";
  if (!maintainCase)
    value = value.toLowerCase();
  return value.replace(regex, "").replace(/ /g, "-");
}

// src/engine/ref.ts
function parseRefAnchor(pos) {
  if (pos === "*") {
    return {
      type: "wildcard"
    };
  } else if (pos === "^begin") {
    return {
      type: "begin"
    };
  } else if (pos === "^end") {
    return {
      type: "end"
    };
  } else if (pos.startsWith("^")) {
    return {
      type: "block",
      name: pos.slice(1)
    };
  } else {
    const [name, lineOffsetStr] = pos.split(",", 2);
    return {
      type: "header",
      name,
      lineOffset: parseInt(lineOffsetStr != null ? lineOffsetStr : "0")
    };
  }
}
function findHeadingByGithubSlug(headings, name) {
  const slugger = new BananaSlug();
  const index = headings.findIndex(({ heading }) => slugger.slug(heading) === name);
  return {
    index,
    heading: headings[index]
  };
}
function anchorToLinkSubpath(anchor, headings) {
  if (anchor.type === "header") {
    let name = anchor.name;
    if (headings) {
      const { heading } = findHeadingByGithubSlug(headings, name);
      if (heading) {
        name = heading.heading;
      }
    }
    return `#${name}`;
  } else if (anchor.type === "block")
    return `#^${anchor.name}`;
  return "";
}
function parseRefSubpath(str) {
  if (str.length > 0) {
    const [startStr, endStr] = str.split(":#", 2);
    const start = parseRefAnchor(startStr);
    let end;
    if (endStr)
      end = parseRefAnchor(endStr);
    return {
      text: str,
      start,
      end
    };
  }
  return void 0;
}

// src/engine/structuredWorkspace.ts
var STRUCTURED_URI_START = "structured://";
var StructuredWorkspace = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.vaultList = [];
  }
  changeVault(configs) {
    this.vaultList = configs.map((config) => new StructuredVault(this.app, config, this.settings));
    this.vaultList.forEach((vault) => vault.init());
  }
  findVaultByParent(parent) {
    return this.vaultList.find((vault) => vault.folder === parent);
  }
  findVaultByParentPath(path) {
    const file = getFolderFile(this.app.vault, path);
    return file instanceof import_obsidian16.TFolder ? this.findVaultByParent(file) : void 0;
  }
  resolveRef(sourcePath, link) {
    var _a, _b;
    if (link.startsWith(STRUCTURED_URI_START)) {
      const [vaultName, rest] = link.slice(STRUCTURED_URI_START.length).split("/", 2);
      const { path: path2, subpath: subpath2 } = rest ? (0, import_obsidian16.parseLinktext)(rest) : {
        path: void 0,
        subpath: void 0
      };
      const vault2 = this.vaultList.find(({ config }) => config.name === vaultName);
      return {
        type: "maybe-note",
        vaultName: vaultName != null ? vaultName : "",
        vault: vault2,
        note: path2 ? (_a = vault2 == null ? void 0 : vault2.tree) == null ? void 0 : _a.getFromFileName(path2, this.settings) : void 0,
        path: path2 != null ? path2 : "",
        subpath: subpath2 ? parseRefSubpath(subpath2) : void 0
      };
    }
    const { dir: vaultDir } = parsePath(sourcePath);
    const vault = this.findVaultByParentPath(vaultDir);
    if (!vault)
      return null;
    const { path: linkPath, subpath } = (0, import_obsidian16.parseLinktext)(link);
    const target = this.app.metadataCache.getFirstLinkpathDest(linkPath, sourcePath);
    if (target && target.extension !== "md")
      return {
        type: "file",
        file: target
      };
    const path = target ? target.basename : linkPath;
    const note = vault.tree.getFromFileName(path, this.settings);
    return {
      type: "maybe-note",
      vaultName: vault.config.name,
      vault,
      note,
      path,
      subpath: parseRefSubpath((_b = subpath.slice(1)) != null ? _b : "")
    };
  }
};

// src/custom-resolver/index.ts
var import_obsidian25 = require("obsidian");

// src/custom-resolver/link-hover.ts
var import_obsidian18 = require("obsidian");

// src/custom-resolver/ref-render.ts
var import_obsidian17 = require("obsidian");
var MarkdownRendererConstructor = import_obsidian17.MarkdownRenderer;
var RefMarkdownRenderer = class extends MarkdownRendererConstructor {
  constructor(parent, queed) {
    super(parent.app, parent.previewEl, queed);
    this.parent = parent;
  }
  get file() {
    return this.parent.file;
  }
  edit(markdown) {
    this.parent.editContent(markdown);
  }
};
var NoteRefRenderChild = class extends import_obsidian17.MarkdownRenderChild {
  constructor(app, containerEl, ref, settings) {
    super(containerEl);
    this.app = app;
    this.containerEl = containerEl;
    this.ref = ref;
    this.found = false;
    if (!ref.note || !ref.note.file)
      throw Error("NoteRefChild only accept ref with non-blank note and file");
    this.file = ref.note.file;
    this.containerEl.classList.add(
      "structured-embed",
      "markdown-embed",
      "inline-embed",
      "is-loaded"
    );
    this.containerEl.setText("");
    const icon = this.containerEl.createDiv("structured-icon");
    (0, import_obsidian17.setIcon)(icon, settings.pluginIcon);
    this.previewEl = this.containerEl.createDiv("markdown-embed-content");
    const buttonComponent = new import_obsidian17.ButtonComponent(this.containerEl);
    buttonComponent.buttonEl.remove();
    buttonComponent.buttonEl = this.containerEl.createDiv(
      "markdown-embed-link"
    );
    buttonComponent.setIcon("lucide-link").setTooltip("Open link");
    buttonComponent.buttonEl.onclick = () => {
      var _a, _b;
      const openState = {};
      if (this.ref.subpath) {
        openState.eState = {
          subpath: anchorToLinkSubpath(
            this.ref.subpath.start,
            (_a = this.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.headings
          )
        };
      }
      openFile(this.app, (_b = this.ref.note) == null ? void 0 : _b.file, { openState });
    };
    this.renderer = new RefMarkdownRenderer(this, true);
    this.addChild(this.renderer);
  }
  async getContent() {
    const content = await this.app.vault.read(this.file);
    if (this.ref.subpath && this.ref.subpath.start && this.ref.subpath.start.type === "header") {
      const cache = this.app.metadataCache.getFileCache(this.file);
      if (cache && cache.headings) {
        const headingName = this.ref.subpath.start.name;
        const heading = cache.headings.find((h) => h.heading === headingName);
        if (heading) {
          const lines = content.split("\n");
          const startLine = heading.position.start.line;
          let endLine = lines.length;
          for (let i = startLine + 1; i < lines.length; i++) {
            if (cache.headings.some((h) => h.position.start.line === i && h.level <= heading.level)) {
              endLine = i;
              break;
            }
          }
          return lines.slice(startLine, endLine).join("\n");
        }
      }
      return `Cannot find section "${this.ref.subpath.start.name}" in ${this.file.basename}`;
    }
    return content;
  }
  editContent(target) {
    if (!this.found || !this.markdown)
      return;
    let md;
    if (!this.range) {
      md = target;
    } else {
      const before = this.markdown.substring(0, this.range.start);
      md = before + target;
      if (this.range.end) {
        const after = this.markdown.substring(this.range.end);
        md += after;
      }
    }
    this.app.vault.modify(this.file, md);
  }
  async loadFile() {
    const content = await this.getContent();
    this.renderer.renderer.set(content);
  }
  onload() {
    super.onload();
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file, data) => {
        if (file === this.file) {
          this.loadFile();
        }
      })
    );
  }
};
var UnresolvedRefRenderChild = class extends import_obsidian17.MarkdownRenderChild {
  constructor(app, containerEl, target, settings) {
    super(containerEl);
    this.containerEl.classList.add("structured-embed", "file-embed", "mod-empty", "is-loaded");
    this.containerEl.setText("");
    const icon = this.containerEl.createDiv("structured-icon");
    (0, import_obsidian17.setIcon)(icon, settings.pluginIcon);
    const content = this.containerEl.createDiv();
    const { vaultName, vault, path } = target;
    if (vaultName === "") {
      content.setText("Vault name are unspecified in link.");
      return;
    } else if (!vault) {
      content.setText(`Vault ${vaultName} are not found.`);
      return;
    } else if (path === "") {
      content.setText("Note path are unspecified in link.");
      return;
    }
    content.setText(`"${target.path}" is not created yet. Click to create.`);
    this.containerEl.onclick = () => {
      vault.createNote(path).then((file) => openFile(app, file));
    };
  }
};
function createRefRenderer(target, app, container, settings) {
  if (!target.note || !target.note.file) {
    return new UnresolvedRefRenderChild(app, container, target, settings);
  } else {
    return new NoteRefRenderChild(app, container, target, settings);
  }
}

// src/custom-resolver/link-hover.ts
function createLinkHoverHandler(app, workspace, originalBoundedFunction) {
  return (parent, targetEl, link, sourcePath, state) => {
    const ref = workspace.resolveRef(sourcePath, link);
    if (!ref || ref.type !== "maybe-note")
      return originalBoundedFunction(parent, targetEl, link, sourcePath, state);
    if (!(parent.hoverPopover && parent.hoverPopover.state !== import_obsidian18.PopoverState.Hidden && parent.hoverPopover.targetEl === targetEl)) {
      const popOver = new import_obsidian18.HoverPopover(parent, targetEl);
      setTimeout(async () => {
        if (popOver.state === import_obsidian18.PopoverState.Hidden)
          return;
        const container = popOver.hoverEl.createDiv();
        const component = createRefRenderer(ref, app, container, workspace.settings);
        popOver.addChild(component);
        if (component instanceof NoteRefRenderChild)
          await component.loadFile();
        if (popOver.state === import_obsidian18.PopoverState.Shown)
          popOver.position();
      }, 100);
    }
  };
}

// src/custom-resolver/index.ts
var import_view3 = require("@codemirror/view");

// src/custom-resolver/ref-live.ts
var import_view = require("@codemirror/view");
var import_obsidian19 = require("obsidian");
var RefLivePlugin = class {
  constructor(app, workspace) {
    this.app = app;
    this.workspace = workspace;
  }
  update(update2) {
    if (!update2.state.field(import_obsidian19.editorLivePreviewField)) {
      return;
    }
    update2.view.state.facet(import_view.EditorView.decorations).forEach((d) => {
      if (typeof d !== "function") {
        const iter = d.iter();
        while (iter.value) {
          const widget = iter.value.spec.widget;
          if (widget && widget.href && widget.sourcePath && widget.title) {
            const internalWidget = widget;
            this.hack(internalWidget);
          }
          iter.next();
        }
      }
    });
  }
  hack(widget) {
    if (widget.hacked) {
      return;
    }
    widget.hacked = true;
    const target = this.workspace.resolveRef(widget.sourcePath, widget.href);
    if (!target || target.type !== "maybe-note")
      return;
    const loadComponent = (widget2) => {
      const renderer = createRefRenderer(
        target,
        this.app,
        widget2.containerEl,
        this.workspace.settings
      );
      if (renderer instanceof NoteRefRenderChild)
        renderer.loadFile();
      widget2.addChild(renderer);
    };
    widget.initDOM = function() {
      this.containerEl = createDiv("internal-embed");
      loadComponent(this);
      return this.containerEl;
    };
    widget.applyTitle = function(container, title) {
      this.title = title;
    };
    if (widget.containerEl) {
      console.log("Workaround");
      widget.children[0].unload();
      widget.children.pop();
      loadComponent(widget);
    }
  }
};

// src/custom-resolver/ref-markdown-processor.ts
function createRefMarkdownProcessor(app, workspace) {
  return (element2, context) => {
    const embeddedItems = element2.querySelectorAll(".internal-embed");
    const promises = [];
    embeddedItems.forEach((el) => {
      const link = el.getAttribute("src");
      if (!link)
        return;
      const target = workspace.resolveRef(context.sourcePath, link);
      if (!target || target.type !== "maybe-note")
        return;
      const renderer = createRefRenderer(target, app, el, workspace.settings);
      if (renderer instanceof NoteRefRenderChild)
        promises.push(renderer.loadFile());
      context.addChild(renderer);
    });
    return Promise.all(promises);
  };
}

// src/custom-resolver/link-open.ts
var import_obsidian20 = require("obsidian");
function createLinkOpenHandler(workspace, originalBoundedFunction) {
  return async (linktext, sourcePath, newLeaf, openViewState) => {
    var _a, _b, _c;
    const target = workspace.resolveRef(sourcePath, linktext);
    if (!target || target.type !== "maybe-note")
      return originalBoundedFunction(linktext, sourcePath, newLeaf, openViewState);
    if (!((_a = target.note) == null ? void 0 : _a.file)) {
      for (const vault of workspace.vaultList) {
        const existingFile = vault.folder.children.find(
          (file2) => file2.name === `${target.path}.md`
        );
        if (existingFile) {
          return originalBoundedFunction(existingFile.path, "", newLeaf, openViewState);
        }
      }
    }
    let file = (_b = target.note) == null ? void 0 : _b.file;
    if (!file) {
      if (target.vaultName === "") {
        new import_obsidian20.Notice("Vault name is unspecified in link.");
        return;
      } else if (!target.vault) {
        new import_obsidian20.Notice(`Vault ${target.vaultName} is not found.`);
        return;
      } else if (target.path === "") {
        new import_obsidian20.Notice("Note path is unspecified in link.");
        return;
      }
      file = await target.vault.createNote(target.path);
    }
    let newLink = file.path;
    if (target.subpath)
      newLink += anchorToLinkSubpath(
        target.subpath.start,
        (_c = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _c.headings
      );
    return originalBoundedFunction(newLink, "", newLeaf, openViewState);
  };
}

// src/custom-resolver/link-live.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_obsidian22 = require("obsidian");
var import_obsidian23 = require("obsidian");

// src/custom-resolver/link-render.ts
var import_obsidian21 = require("obsidian");
function renderLinkTitle(app, workspace, href, title, sourcePath) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (title)
    return title;
  const ref = workspace.resolveRef(sourcePath, href);
  if (!ref || ref.type !== "maybe-note")
    return href;
  if ((_a = ref.note) == null ? void 0 : _a.file) {
    const fileTitle = (_c = (_b = app.metadataCache.getFileCache(ref.note.file)) == null ? void 0 : _b.frontmatter) == null ? void 0 : _c["title"];
    return fileTitle != null ? fileTitle : href;
  }
  const sourceVault = workspace.findVaultByParentPath(sourcePath);
  if (sourceVault) {
    const existingFile = sourceVault.folder.children.find(
      (file) => file instanceof import_obsidian21.TFile && file.name === `${ref.path}.md`
    );
    if (existingFile instanceof import_obsidian21.TFile) {
      const fileTitle = (_e = (_d = app.metadataCache.getFileCache(existingFile)) == null ? void 0 : _d.frontmatter) == null ? void 0 : _e["title"];
      if (fileTitle)
        return fileTitle;
    }
  }
  const matchingFiles = [];
  for (const vault of workspace.vaultList) {
    if (vault === sourceVault)
      continue;
    const existingFile = vault.folder.children.find(
      (file) => file instanceof import_obsidian21.TFile && file.name === `${ref.path}.md`
    );
    if (existingFile instanceof import_obsidian21.TFile) {
      matchingFiles.push(existingFile);
    }
  }
  if (matchingFiles.length === 1) {
    const fileTitle = (_g = (_f = app.metadataCache.getFileCache(matchingFiles[0])) == null ? void 0 : _f.frontmatter) == null ? void 0 : _g["title"];
    if (fileTitle)
      return fileTitle;
  }
  return href;
}

// src/custom-resolver/link-live.ts
var LinkWidget = class extends import_view2.WidgetType {
  constructor(app, workspace, sourcePath, href, title) {
    super();
    this.app = app;
    this.workspace = workspace;
    this.sourcePath = sourcePath;
    this.href = href;
    this.title = title;
  }
  initDOM() {
    this.containerEl = createSpan(
      {
        cls: "cm-hmd-internal-link"
      },
      (el) => {
        el.createSpan({
          cls: "cm-underline"
        });
      }
    );
    this.updateTitle();
    this.containerEl.addEventListener("click", () => {
      this.app.workspace.openLinkText(this.href, this.sourcePath);
    });
  }
  updateTitle() {
    this.containerEl.children[0].setText(
      renderLinkTitle(this.app, this.workspace, this.href, this.title, this.sourcePath)
    );
  }
  toDOM(view) {
    if (!this.containerEl)
      this.initDOM();
    return this.containerEl;
  }
};
var LinkLivePlugin = class {
  constructor(app, workspace, editorView) {
    this.app = app;
    this.workspace = workspace;
    this.editorView = editorView;
    this.decorations = import_view2.Decoration.none;
    this.widgets = [];
    this.decorations = this.buildDecorations(editorView);
  }
  update(update2) {
    this.decorations = this.buildDecorations(update2.view);
  }
  getLinks(view) {
    const links = [];
    for (const { from, to } of view.visibleRanges) {
      let linkStart = -1;
      let linkTitle = void 0;
      let linkHref = "";
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter(node) {
          const tokenClass = node.type.prop(import_language.tokenClassNodeProp);
          if (!tokenClass)
            return;
          const tokenClassList = tokenClass.split(" ");
          if (tokenClassList.contains("formatting-link-start") && !tokenClassList.contains("formatting-embed")) {
            linkStart = node.from;
          } else if (linkStart >= 0) {
            if (tokenClassList.contains("hmd-internal-link")) {
              const text2 = view.state.doc.sliceString(node.from, node.to);
              if (tokenClassList.contains("link-has-alias")) {
                linkTitle = text2;
              } else {
                linkHref = text2;
              }
            } else if (tokenClassList.contains("formatting-link-end")) {
              links.push({
                start: linkStart,
                end: node.to,
                href: linkHref,
                title: linkTitle,
                hasAlias: !!linkTitle,
                showSource: true
              });
              linkStart = -1;
              linkTitle = void 0;
              linkHref = "";
            }
          }
        }
      });
    }
    return links;
  }
  configureLinkVisibility(links, view) {
    const prevDecorations = view.state.facet(import_view2.EditorView.decorations);
    for (const decorFn of prevDecorations) {
      if (typeof decorFn !== "function")
        continue;
      const decor = decorFn(view);
      const iter = decor.iter();
      let found = false;
      while (iter.value) {
        const decorValue = iter.value;
        if ("isReplace" in decorValue && decorValue.isReplace) {
          const link = links.find(({ start }) => start === iter.from);
          if (link) {
            found = true;
            link.showSource = false;
            if (link.hasAlias) {
              iter.next();
              iter.next();
              iter.next();
            } else {
              iter.next();
            }
            iter.next();
          }
        }
        iter.next();
      }
      if (found)
        break;
    }
  }
  getWidget(link, sourcePath) {
    const lastWidgetIndex = this.widgets.findIndex(
      (widget) => widget.href === link.href && widget.sourcePath === sourcePath
    );
    if (lastWidgetIndex >= 0) {
      const widget = this.widgets[lastWidgetIndex];
      widget.title = link.title;
      widget.updateTitle();
      this.widgets.splice(lastWidgetIndex, 1);
      return widget;
    }
    return new LinkWidget(this.app, this.workspace, sourcePath, link.href, link.title);
  }
  buildDecorations(view) {
    var _a, _b;
    if (!view.state.field(import_obsidian23.editorLivePreviewField)) {
      return import_view2.Decoration.none;
    }
    const links = this.getLinks(view);
    if (links.length === 0)
      return import_view2.Decoration.none;
    this.configureLinkVisibility(links, view);
    const builder = new import_state.RangeSetBuilder();
    const currentWidgets = [];
    const sourcePath = (_b = (_a = view.state.field(import_obsidian22.editorInfoField).file) == null ? void 0 : _a.path) != null ? _b : "";
    for (const link of links) {
      if (link.showSource)
        continue;
      const widget = this.getWidget(link, sourcePath);
      currentWidgets.push(widget);
      builder.add(
        link.start,
        link.end,
        import_view2.Decoration.widget({
          widget
        })
      );
    }
    this.widgets = currentWidgets;
    return builder.finish();
  }
};

// src/custom-resolver/link-markdown-processor.ts
function createLinkMarkdownProcessor(app, workspace) {
  return (el, ctx) => {
    console.log();
    const linksEl = el.querySelectorAll(".internal-link");
    if (linksEl.length == 0)
      return;
    const section = ctx.getSectionInfo(el);
    const cache = app.metadataCache.getCache(ctx.sourcePath);
    if (!section || !(cache == null ? void 0 : cache.links))
      return;
    const links = cache.links.filter(
      (link) => link.position.start.line >= section.lineStart && link.position.end.line <= section.lineEnd
    );
    if (links.length !== linksEl.length) {
      console.warn("Cannot post process link");
      return;
    }
    linksEl.forEach((el2, index) => {
      const link = links[index];
      if (!link.original.startsWith("[[") || !link.original.endsWith("]]"))
        return;
      let title, href;
      const split = link.original.substring(2, link.original.length - 2).split("|", 2);
      if (split.length == 1)
        href = split[0];
      else {
        title = split[0];
        href = split[1];
      }
      const titleText = renderLinkTitle(app, workspace, href, title, ctx.sourcePath);
      el2.setText(titleText);
      el2.setAttribute("href", href);
      el2.setAttribute("data-href", href);
      el2.setAttribute("aria-label", href);
      el2.setAttribute("data-tooltip-position", "top");
    });
  };
}

// src/custom-resolver/link-ref-clickbale.ts
var import_obsidian24 = require("obsidian");
var LinkRefClickbale = class {
  constructor(view) {
    this.view = view;
    const editor = view.state.field(import_obsidian24.editorInfoField).editor;
    if (editor && editor.getClickableTokenAt) {
      this.getClickableTokenAtOrig = editor.getClickableTokenAt;
      editor.getClickableTokenAt = LinkRefClickbale.createClickableTokenAtWrapper(
        this.getClickableTokenAtOrig
      );
    }
  }
  static createClickableTokenAtWrapper(original) {
    return function(...args) {
      const result = original.call(this, ...args);
      if (result && result.type === "internal-link") {
        const raw = this.getRange(result.start, result.end);
        const split = raw.split("|", 2);
        if (split.length === 2) {
          result.text = split[1];
        }
      }
      return result;
    };
  }
  destroy() {
    if (this.getClickableTokenAtOrig) {
      const editor = this.view.state.field(import_obsidian24.editorInfoField).editor;
      if (editor) {
        editor.getClickableTokenAt = this.getClickableTokenAtOrig;
      }
    }
  }
};

// src/custom-resolver/index.ts
var CustomResolver = class extends import_obsidian25.Component {
  constructor(plugin2, workspace) {
    super();
    this.plugin = plugin2;
    this.workspace = workspace;
    this.refPostProcessor = createRefMarkdownProcessor(this.plugin.app, this.workspace);
    this.linkPostProcessor = createLinkMarkdownProcessor(this.plugin.app, this.workspace);
    this.refEditorExtenstion = import_view3.ViewPlugin.define((v) => {
      return new RefLivePlugin(this.plugin.app, this.workspace);
    });
    this.linkEditorExtenstion = import_view3.ViewPlugin.define(
      (view) => {
        return new LinkLivePlugin(this.plugin.app, this.workspace, view);
      },
      {
        decorations: (value) => value.decorations
      }
    );
    this.linkRefClickbaleExtension = import_view3.ViewPlugin.define((v) => {
      return new LinkRefClickbale(v);
    });
  }
  onload() {
    this.plugin.app.workspace.onLayoutReady(() => {
      this.plugin.app.workspace.registerEditorExtension(this.refEditorExtenstion);
      this.plugin.app.workspace.registerEditorExtension(this.linkEditorExtenstion);
      this.plugin.app.workspace.registerEditorExtension(this.linkRefClickbaleExtension);
      this.pagePreviewPlugin = this.plugin.app.internalPlugins.getEnabledPluginById("page-preview");
      if (!this.pagePreviewPlugin)
        return;
      this.originalLinkHover = this.pagePreviewPlugin.onLinkHover;
      this.pagePreviewPlugin.onLinkHover = createLinkHoverHandler(
        this.plugin.app,
        this.workspace,
        this.originalLinkHover.bind(this.pagePreviewPlugin)
      );
    });
    import_obsidian25.MarkdownPreviewRenderer.registerPostProcessor(this.refPostProcessor);
    import_obsidian25.MarkdownPreviewRenderer.registerPostProcessor(this.linkPostProcessor);
    this.originalOpenLinkText = this.plugin.app.workspace.openLinkText;
    this.plugin.app.workspace.openLinkText = createLinkOpenHandler(
      this.workspace,
      this.originalOpenLinkText.bind(this.plugin.app.workspace)
    );
  }
  onunload() {
    this.plugin.app.workspace.openLinkText = this.originalOpenLinkText;
    import_obsidian25.MarkdownPreviewRenderer.unregisterPostProcessor(this.linkPostProcessor);
    import_obsidian25.MarkdownPreviewRenderer.unregisterPostProcessor(this.refPostProcessor);
    this.plugin.app.workspace.unregisterEditorExtension(this.linkRefClickbaleExtension);
    this.plugin.app.workspace.unregisterEditorExtension(this.linkEditorExtenstion);
    this.plugin.app.workspace.unregisterEditorExtension(this.refEditorExtenstion);
    if (!this.pagePreviewPlugin)
      return;
    this.pagePreviewPlugin.onLinkHover = this.originalLinkHover;
  }
};

// src/custom-graph/index.ts
var import_obsidian27 = require("obsidian");

// src/custom-graph/data-engine-render.ts
var import_obsidian26 = require("obsidian");

// src/custom-graph/utils.ts
function isGraphView(view) {
  return view.getViewType() === "graph";
}
function isLocalGraphView(view) {
  return view.getViewType() === "localgraph";
}
function getHierarchyRelationship(note1Path, note2Path) {
  const parts1 = note1Path.split(".");
  const parts2 = note2Path.split(".");
  if (!note1Path.startsWith(parts2[0]) && !note2Path.startsWith(parts1[0])) {
    return null;
  }
  if (note1Path.startsWith(parts2[0])) {
    return parts1.length - parts2.length;
  } else {
    return parts2.length - parts1.length;
  }
}
function getHierarchyWeight(levelDifference) {
  return 1 / Math.abs(levelDifference);
}

// src/custom-graph/data-engine-render.ts
function createDataEngineRender(app, workspace) {
  return function() {
    const nodes = {};
    const files = app.vault.getFiles();
    for (const file of files) {
      const vault = workspace.findVaultByParent(file.parent);
      const id = file.path;
      if (vault) {
        const note = vault.tree.getFromFileName(file.basename, workspace.settings);
        if (note) {
          nodes[id] = {
            type: "note",
            file,
            vault,
            note,
            connections: []
          };
          continue;
        }
      }
      nodes[id] = {
        type: "file",
        file,
        connections: []
      };
    }
    function addHierarchicalConnections() {
      Object.values(nodes).forEach((node1) => {
        if (node1.type !== "note")
          return;
        Object.values(nodes).forEach((node2) => {
          if (node2.type !== "note" || node1 === node2)
            return;
          const relationship = getHierarchyRelationship(node1.note.getPath(), node2.note.getPath());
          if (relationship) {
            const source = node1.file.path;
            const target = node2.file.path;
            nodes[source].connections.push({
              type: "hierarchy",
              sourceNode: source,
              targetNode: target,
              weight: getHierarchyWeight(relationship)
            });
          }
        });
      });
    }
    function addBacklinkConnections() {
      Object.values(nodes).forEach((node) => {
        const links = app.metadataCache.resolvedLinks[node.file.path] || {};
        Object.keys(links).forEach((targetPath) => {
          if (nodes[targetPath]) {
            node.connections.push({
              type: "backlink",
              sourceNode: node.file.path,
              targetNode: targetPath,
              weight: 1
            });
          }
        });
      });
    }
    addHierarchicalConnections();
    addBacklinkConnections();
    const graphNodes = {};
    Object.entries(nodes).forEach(([id, node]) => {
      graphNodes[id] = {
        id,
        text: node.file.basename,
        links: {},
        matches: true,
        score: 1
      };
      node.connections.forEach((connection) => {
        graphNodes[id].links[connection.targetNode] = {
          type: connection.type,
          weight: connection.weight
        };
      });
    });
    return graphNodes;
  };
}

// src/custom-graph/node-text.ts
function createNodeTextHandler(workspace) {
  return function() {
    var _a, _b;
    const id = this.id;
    if (id.startsWith(STRUCTURED_URI_START)) {
      const ref = workspace.resolveRef("", id);
      if (!ref || ref.type === "file")
        return id;
      const title = (_b = (_a = ref.note) == null ? void 0 : _a.title) != null ? _b : ref.path;
      if (workspace.vaultList.length > 1)
        return `${title} (${ref.vaultName})`;
      return title;
    } else {
      const parts = id.split("/");
      const filename = parts[parts.length - 1];
      return filename.split(".").slice(0, -1).join(".") || filename;
    }
  };
}

// src/custom-graph/index.ts
var CustomGraph = class extends import_obsidian27.Component {
  constructor(plugin2, workspace) {
    super();
    this.plugin = plugin2;
    this.workspace = workspace;
  }
  onload() {
    this.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", (leaf) => {
        const view = leaf == null ? void 0 : leaf.view;
        if (!view)
          return;
        const isGlobal = isGraphView(view);
        const isLocal = isLocalGraphView(view);
        if (isGlobal || isLocal) {
          const renderFn = () => {
            const data = createDataEngineRender(this.plugin.app, this.workspace)();
            return Object.keys(data).length;
          };
          if (isGlobal)
            view.dataEngine.render = renderFn;
          else
            view.engine.render = renderFn;
          const nodes = view.renderer.nodes;
          const replace = () => {
            if (nodes.length > 0) {
              const firstNode = nodes[0];
              console.log(firstNode);
              Object.getPrototypeOf(firstNode)["getDisplayText"] = createNodeTextHandler(
                this.workspace
              );
            } else {
              view.renderer.setData({
                nodes: {
                  Waker: {
                    links: {},
                    type: ""
                  }
                }
              });
              replace();
            }
          };
          replace();
        }
      })
    );
  }
};

// src/commands/lookupNote.ts
function lookupNoteCommand(app, workspace, settings) {
  return {
    id: "structured-lookup",
    name: "Lookup note",
    callback: () => {
      new LookupModal(
        app,
        workspace,
        "",
        // initialQuery
        void 0,
        // onCreateInVault
        settings.excludedPaths
      ).open();
    }
  };
}

// src/commands/renameNote.ts
var import_obsidian28 = require("obsidian");
function renameNoteCommand(app, workspace, updateNoteStore) {
  return {
    id: "rename-structured-note",
    name: "Rename note",
    callback: () => renameCurrentNote(app, workspace, updateNoteStore)
  };
}
async function renameCurrentNote(app, workspace, updateNoteStore) {
  const activeFile2 = app.workspace.getActiveFile();
  if (activeFile2) {
    const vault = workspace.findVaultByParent(activeFile2.parent);
    if (vault) {
      new RenameNoteModal(app, activeFile2, async (newName) => {
        await vault.noteRenamer.renameNote(activeFile2, newName);
        updateNoteStore();
      }).open();
    }
  } else {
    new import_obsidian28.Notice("No active file");
  }
}

// src/commands/collapseAll.ts
function collapseAllCommand(app) {
  return {
    id: "structured-tree-collapse-all",
    name: "Collapse all",
    callback: () => collapseAllButTop(app)
  };
}
function collapseAllButTop(app) {
  app.workspace.getLeavesOfType(VIEW_TYPE_STRUCTURED).forEach((leaf) => {
    if (leaf.view instanceof StructuredView) {
      leaf.view.collapseAllButTop();
    }
  });
}

// src/commands/generateId.ts
var import_obsidian29 = require("obsidian");
function generateIdCommand(app, workspace, settings, updateNoteStore) {
  return {
    id: "generate-id-for-note",
    name: "Generate ID",
    callback: () => addIdToCurrentNote(app, workspace, settings, updateNoteStore)
  };
}
async function addIdToCurrentNote(app, workspace, settings, updateNoteStore) {
  const activeFile2 = app.workspace.getActiveFile();
  if (!activeFile2) {
    new import_obsidian29.Notice("No active file");
    return;
  }
  const vault = workspace.findVaultByParent(activeFile2.parent);
  if (!vault) {
    new import_obsidian29.Notice("File is not in a structured vault");
    return;
  }
  const fileContents = await app.vault.read(activeFile2);
  const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
  const frontmatterMatch = fileContents.match(frontmatterRegex);
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    const frontmatterLines = frontmatter.split("\n");
    const idLine = `${settings.idKey}: "${generateUUID()}"`;
    if (!frontmatterLines.some((line) => line.startsWith(`${settings.idKey}:`))) {
      frontmatterLines.unshift(idLine);
      const newFrontmatter = frontmatterLines.join("\n");
      const newContents = fileContents.replace(frontmatterRegex, `---
${newFrontmatter}
---`);
      await app.vault.modify(activeFile2, newContents);
      new import_obsidian29.Notice("ID generated");
      vault.onMetadataChanged(activeFile2);
      updateNoteStore();
    } else {
      new import_obsidian29.Notice("Note already has an ID");
    }
  } else {
    const newContents = `---
${settings.idKey}: "${generateUUID()}"
---

${fileContents}`;
    await app.vault.modify(activeFile2, newContents);
    new import_obsidian29.Notice("ID generated");
    vault.onMetadataChanged(activeFile2);
    updateNoteStore();
  }
}

// src/commands/openParentNote.ts
var import_obsidian30 = require("obsidian");
function openParentNoteCommand(app, workspace) {
  return {
    id: "open-parent-note",
    name: "Open parent note",
    callback: () => openParentNote(app, workspace)
  };
}
async function openParentNote(app, workspace) {
  const activeFile2 = app.workspace.getActiveFile();
  if (!activeFile2) {
    new import_obsidian30.Notice("No active file");
    return;
  }
  const vault = workspace.findVaultByParent(activeFile2.parent);
  if (!vault) {
    new import_obsidian30.Notice("File is not in a structured vault");
    return;
  }
  const note = vault.tree.getFromFileName(activeFile2.basename, workspace.settings);
  if (!note) {
    new import_obsidian30.Notice("Cannot find note in structured tree");
    return;
  }
  const parentNote = note.parent;
  if (!parentNote || parentNote === vault.tree.root) {
    new import_obsidian30.Notice("This is a root note");
    return;
  }
  if (parentNote.file instanceof import_obsidian30.TFile) {
    const leaf = app.workspace.getLeaf();
    await leaf.openFile(parentNote.file);
  } else {
    new import_obsidian30.Notice("Parent note file not found");
  }
}

// src/commands/exportNotes.ts
var import_obsidian31 = require("obsidian");
var import_obsidian32 = require("obsidian");
function exportNotesCommand(app, workspace, settings) {
  return {
    id: "structured-tree-export-notes",
    name: "Export hierarchy as folders",
    callback: () => exportNotesToStandardStructure(app, workspace, settings)
  };
}
async function exportNotesToStandardStructure(app, workspace, settings) {
  try {
    new import_obsidian31.Notice("Starting export to standard structure...");
    const exportFolder = await createExportFolder(app);
    let exportedCount = 0;
    let failedCount = 0;
    for (const vault of workspace.vaultList) {
      if (!vault.isIniatialized)
        continue;
      const vaultExportFolder = await app.vault.createFolder(
        (0, import_obsidian32.normalizePath)(`${exportFolder.path}/${vault.config.name}`)
      );
      const rootNotes = vault.tree.root.children;
      for (const rootNote of rootNotes) {
        try {
          const exported = await exportNoteWithHierarchy(app, rootNote, vaultExportFolder, settings, "");
          exportedCount += exported;
        } catch (error) {
          console.error(`Failed to export note hierarchy starting from ${rootNote.title}:`, error);
          failedCount++;
        }
      }
    }
    if (exportedCount > 0) {
      new import_obsidian31.Notice(`Successfully exported ${exportedCount} notes to ${exportFolder.path}`);
    }
    if (failedCount > 0) {
      new import_obsidian31.Notice(`Failed to export ${failedCount} notes`);
    }
  } catch (error) {
    new import_obsidian31.Notice(`Export failed: ${error}`);
  }
}
async function exportNoteWithHierarchy(app, note, parentFolder, settings, pathPrefix) {
  let exportedCount = 0;
  const title = note.title;
  const sanitizedTitle = sanitizeFileName(title);
  const hasChildren = note.children.length > 0;
  let currentFolder = parentFolder;
  let noteFilePath;
  if (hasChildren) {
    const folderPath = (0, import_obsidian32.normalizePath)(`${parentFolder.path}/${sanitizedTitle}`);
    try {
      currentFolder = await app.vault.createFolder(folderPath);
    } catch (error) {
      currentFolder = app.vault.getAbstractFileByPath(folderPath);
    }
    if (note.file) {
      noteFilePath = (0, import_obsidian32.normalizePath)(`${currentFolder.path}/${sanitizedTitle}.${note.file.extension}`);
      noteFilePath = await getUniqueFilePath(app, noteFilePath);
      const content = await app.vault.read(note.file);
      await app.vault.create(noteFilePath, content);
      exportedCount++;
    }
    for (const childNote of note.children) {
      const childExported = await exportNoteWithHierarchy(
        app,
        childNote,
        currentFolder,
        settings,
        `${pathPrefix}${sanitizedTitle}/`
      );
      exportedCount += childExported;
    }
  } else {
    if (note.file) {
      noteFilePath = (0, import_obsidian32.normalizePath)(`${parentFolder.path}/${sanitizedTitle}.${note.file.extension}`);
      noteFilePath = await getUniqueFilePath(app, noteFilePath);
      const content = await app.vault.read(note.file);
      await app.vault.create(noteFilePath, content);
      exportedCount++;
    }
  }
  return exportedCount;
}
async function createExportFolder(app) {
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, "-");
  const exportPath = `Exported Notes ${timestamp}`;
  try {
    return await app.vault.createFolder(exportPath);
  } catch (error) {
    throw new Error(`Failed to create export folder: ${error}`);
  }
}
function sanitizeFileName(title) {
  return title.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim();
}
async function getUniqueFilePath(app, basePath) {
  let counter = 1;
  let targetPath = basePath;
  while (await app.vault.adapter.exists(targetPath)) {
    const pathParts = basePath.split(".");
    const extension = pathParts.pop();
    const nameWithoutExt = pathParts.join(".");
    targetPath = `${nameWithoutExt} (${counter}).${extension}`;
    counter++;
  }
  return targetPath;
}

// src/main.ts
var StructuredTreePlugin = class extends import_obsidian33.Plugin {
  constructor() {
    super(...arguments);
    this.ribbonElId = "structured-ribbon-icon";
    this.onCreateFile = async (file) => {
      const vault = this.workspace.findVaultByParent(file.parent);
      if (vault && vault.onFileCreated(file)) {
        if (this.settings.autoGenerateFrontmatter && file instanceof import_obsidian33.TFile && file.stat.size === 0)
          await vault.generateFrontmatter(file);
        this.updateNoteStore();
      }
    };
    this.onDeleteFile = (file) => {
      const parsed = parsePath(file.path);
      const vault = this.workspace.findVaultByParentPath(parsed.dir);
      if (vault && vault.onFileDeleted(parsed)) {
        this.updateNoteStore();
      }
    };
    this.onRenameFile = (file, oldPath) => {
      const oldParsed = parsePath(oldPath);
      const oldVault = this.workspace.findVaultByParentPath(oldParsed.dir);
      let update2 = false;
      if (oldVault) {
        update2 = oldVault.onFileDeleted(oldParsed);
      }
      const newVault = this.workspace.findVaultByParent(file.parent);
      if (newVault) {
        update2 = newVault.onFileCreated(file) || update2;
      }
      if (update2)
        this.updateNoteStore();
    };
    this.onFileMenu = (menu, file) => {
      if (!(file instanceof import_obsidian33.TFile))
        return;
      menu.addItem((item) => {
        item.setIcon(this.settings.pluginIcon).setTitle("Reveal in Structured Tree").onClick(() => this.revealFile(file));
      });
    };
    this.onResolveMetadata = (file) => {
      const vault = this.workspace.findVaultByParent(file.parent);
      if (vault && vault.onMetadataChanged(file)) {
        this.updateNoteStore();
      }
    };
  }
  async onload() {
    await this.loadSettings();
    await this.migrateSettings();
    this.configureCustomGraph();
    this.workspace = new StructuredWorkspace(this.app, this.settings);
    (0, import_obsidian33.addIcon)(structuredActivityBarName, structuredActivityBarIcon);
    this.addCommand(lookupNoteCommand(this.app, this.workspace, this.settings));
    this.addCommand(createNewNoteCommand(this.app, this.workspace));
    this.addCommand(renameNoteCommand(this.app, this.workspace, () => this.updateNoteStore()));
    this.addCommand(moveNoteCommand(this.app, this.workspace));
    this.addCommand(collapseAllCommand(this.app));
    this.addCommand(
      generateIdCommand(this.app, this.workspace, this.settings, () => this.updateNoteStore())
    );
    this.addCommand(openParentNoteCommand(this.app, this.workspace));
    this.addCommand({
      id: "open-structured-tree",
      name: "Open Tree",
      callback: () => this.activateView()
    });
    this.addCommand(exportNotesCommand(this.app, this.workspace, this.settings));
    this.addSettingTab(new StructuredTreeSettingTab(this.app, this));
    this.registerView(VIEW_TYPE_STRUCTURED, (leaf) => new StructuredView(leaf, this));
    this.addRibbonIcon(this.settings.pluginIcon, "Open Structured Tree", () => {
      this.activateView();
    }).setAttr("id", this.ribbonElId);
    this.app.workspace.onLayoutReady(() => {
      this.onRootFolderChanged();
      this.registerEvent(this.app.vault.on("create", this.onCreateFile));
      this.registerEvent(this.app.vault.on("delete", this.onDeleteFile));
      this.registerEvent(this.app.vault.on("rename", this.onRenameFile));
      this.registerEvent(this.app.metadataCache.on("resolve", this.onResolveMetadata));
      this.registerEvent(this.app.workspace.on("file-open", this.onOpenFile, this));
      this.registerEvent(this.app.workspace.on("file-menu", this.onFileMenu));
      this.configureCustomResolver();
      this.configureCustomGraph();
    });
  }
  async migrateSettings() {
    function pathToVaultConfig(path) {
      const { name } = parsePath(path);
      if (name.length === 0)
        return {
          name: "root",
          path: "/"
        };
      let processed = path;
      if (processed.endsWith("/"))
        processed = processed.slice(0, -1);
      if (processed.startsWith("/") && processed.length > 1)
        processed = processed.slice(1);
      return {
        name,
        path: processed
      };
    }
    if (this.settings.vaultPath) {
      this.settings.vaultList = [pathToVaultConfig(this.settings.vaultPath)];
      this.settings.vaultPath = void 0;
      await this.saveSettings();
    }
    if (this.settings.vaultList.length > 0 && typeof this.settings.vaultList[0] === "string") {
      this.settings.vaultList = this.settings.vaultList.map(
        (path) => pathToVaultConfig(path)
      );
      await this.saveSettings();
    }
  }
  onunload() {
  }
  onRootFolderChanged() {
    this.workspace.changeVault(this.settings.vaultList);
    this.updateNoteStore();
  }
  configureCustomResolver() {
    if (this.settings.customResolver && !this.customResolver) {
      this.customResolver = new CustomResolver(this, this.workspace);
      this.addChild(this.customResolver);
    } else if (!this.settings.customResolver && this.customResolver) {
      this.removeChild(this.customResolver);
      this.customResolver = void 0;
    }
  }
  configureCustomGraph() {
    if (this.settings.customGraph && !this.customGraph) {
      this.customGraph = new CustomGraph(this, this.workspace);
      this.addChild(this.customGraph);
      this.initializeCustomGraphForExistingViews();
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", (leaf) => {
          if (leaf && leaf.view && leaf.view.getViewType() === "graph") {
            this.initializeCustomGraphForExistingViews();
          }
        })
      );
    } else if (!this.settings.customGraph && this.customGraph) {
      this.removeChild(this.customGraph);
      this.customGraph = void 0;
    }
  }
  initializeCustomGraphForExistingViews() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian33.View && leaf.view.getViewType() === "graph") {
        const graphView = leaf.view;
        if (this.isGraphViewWithRenderer(graphView)) {
          setTimeout(() => {
            var _a, _b;
            (_b = (_a = graphView.renderer) == null ? void 0 : _a.engine) == null ? void 0 : _b.render();
          }, 100);
        }
      }
    });
  }
  isGraphViewWithRenderer(view) {
    return "renderer" in view && typeof view.renderer === "object" && view.renderer !== null && typeof view.renderer === "object" && "engine" in view.renderer;
  }
  updateNoteStore() {
    structuredVaultList.set(this.workspace.vaultList);
  }
  onOpenFile(file) {
    activeFile.set(file);
    if (file && this.settings.autoReveal)
      this.revealFile(file);
  }
  async revealFile(file) {
    const vault = this.workspace.findVaultByParent(file.parent);
    if (!vault)
      return;
    const note = vault.tree.getFromFileName(file.basename, this.settings);
    if (!note)
      return;
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_STRUCTURED);
    for (const leaf of leaves) {
      if (leaf.view instanceof StructuredView) {
        leaf.view.component.focusTo(vault, note);
        return;
      }
    }
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_STRUCTURED);
    if (leaves.length == 0) {
      const leaf = this.app.workspace.getLeftLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_STRUCTURED,
          active: true
        });
        this.app.workspace.revealLeaf(leaf);
      }
    } else {
      leaves.forEach((leaf) => {
        if (leaf.view instanceof StructuredView) {
          this.app.workspace.revealLeaf(leaf);
        }
      });
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.hierarchySeparator = this.settings.hierarchySeparator || ".";
    if (!this.settings.excludedPaths) {
      this.settings.excludedPaths = [];
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.workspace.vaultList.forEach((vault) => vault.updateAcceptedExtensionsCache());
    this.app.workspace.trigger("structured-tree:settings-changed");
  }
  updateRibbonIcon() {
    const ribbonIconEl = document.getElementById(this.ribbonElId);
    if (!ribbonIconEl) {
      return;
    }
    (0, import_obsidian33.setIcon)(ribbonIconEl, this.settings.pluginIcon);
  }
  updateViewLeafIcon() {
    let leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_STRUCTURED);
    if (leaves.length == 0) {
      return;
    }
    let leaf = leaves[0];
    leaf.detach();
    this.activateView();
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/

/* nosourcemap */